[
  {
    "order": 1,
    "title": "Flow Control",
    "subtitle": "With examples from The Dune",
    "url": "https://medium.com/rustaceans/rust-conditionals-a-fun-guide-with-examples-85e831c86501?sk=94edf6b826f7e5fe350f8d5f082ca6bd",
    "snippets": [
      {
        "heading": "Conditional Statements",
        "content": "In the world of \u201cDune,\u201c making decisions is crucial for survival, much like using conditional statements in Rust.\n\nImagine Paul Atreides standing at a crossroads in the desert.\n\n```rust\nfn main() {\n  let water_still = true;\n  let sandworm_nearby = false;\n\n  // Go on if there's water and no sandworm\n  if water_still && !sandworm_nearby {\n    println!(\\\u201cPaul can refill his water.\\\u201c);\n  } else if sandworm_nearby {\n    println!(\\\u201cDanger! A sandworm is near.\\\u201c);\n  } else {\n    println!(\\\u201cNo water source found.\\\u201c);\n  }\n}\n```\n\nIn this snippet, `if` and `else if` statements help Paul decide his course of action based on the conditions he encounters.",
        "task": "Following the logic from the code example, write your own conditional statements in Rust that handle different scenarios based on multiple conditions. Use a fictional or real-world context to frame your scenario.\n\n```rust\nfn main() {\n  /* TODO: Define your variables and conditions */\n  /* TODO: Write if, else if, and else statements based on your conditions */\n}\n```\n\n**Plan:**\n1. Define at least two boolean variables representing different conditions in your chosen context.\n2. Write `if`, `else if`, and `else` statements to respond to these conditions.\n3. Ensure that your conditional statements cover all possible outcomes. Start by defining your variables and conditions."
      },
      {
        "heading": "While Loops",
        "content": "In \u201cDune,\u201c the ongoing battle for control over Arrakis leads to the endless repetition found in loops.\n\nFor instance, perhaps Paul must oversee the harvesting of the spice --- a process that would simply repeat until a quota was filled:\n\n```rust\nfn main() {\n  let mut spice_harvested = 0;\n  let spice_quota = 100;\n\n  // Using a while loop to continue harvesting until the quota is met\n  while spice_harvested < spice_quota {\n    spice_harvested += 10;  // Harvest 10 units of spice\n    println!(\\\u201cHarvested {} units of spice.\\\u201c, spice_harvested);\n  }\n\n  println!(\\\u201cSpice quota met!\\\u201c);\n}\n```\n\nHere, the `while` loop allows Paul to continue the spice harvest until the desired amount is achieved.",
        "task": "Use the example as a guide to implement your own `while` loop in Rust that performs a repetitive task until a specific condition is met. Create a scenario relevant to your interests or another fictional or real-world example.\n\n```rust\nfn main() {\n  /* TODO: Initialize your variables */\n  /* TODO: Construct a while loop to perform your task until the condition is met */\n}\n```\n\n**Plan:**\n1. Initialize variables relevant to your scenario.\n2. Construct a `while` loop that will continue to perform a specific task until your defined condition is met.\n3. Inside the loop, update variables and print statements to reflect the progression of the task. Begin by initializing your variables."
      },
      {
        "heading": "For Loops",
        "content": "Like the Fremen traversing predetermined paths across the desert, `for` loops in Rust iterate over a range or collection.\n\nPaul decides to train a group of Fremen warriors.\n\n```rust\nfn main() {\n  let fremen_warriors = [\\\u201cStilgar\\\u201c, \\\u201cChani\\\u201c, \\\u201cDuncan Idaho\\\u201c];\n\n  // Using a for loop to train each warrior\n  for warrior in fremen_warriors.iter() {\n    println!(\\\u201c{} is training.\\\u201c, warrior);\n  }\n\n  println!(\\\u201cAll Fremen warriors have completed their training!\\\u201c);\n}\n```\n\nNotice that here the `for` loop iterates over the array of Fremen warriors. Each iteration means there is a training session for a warrior.",
        "task": "Drawing inspiration from the example, create your own `for` loop in Rust that iterates through a collection of items. Define the collection according to your chosen theme or scenario. Describe each item's role or action during the iteration in the loop's body.\n\n```rust\nfn main() {\n  /* TODO: Define your collection */\n  /* TODO: Use a for loop to iterate through the collection and perform actions */\n}\n```\n\n**Plan:**\n1. Define a collection of items relevant to your theme or scenario.\n2. Write a `for` loop to iterate through this collection.\n3. For each item in the collection, execute an action and print a message indicating what is happening. Start by defining your collection."
      },
      {
        "heading": "Nested Loops",
        "content": "Nested loops are like the layered strategies in the politics of Dune.\n\nThink of Paul's political situation in Arrakeen.\n\n```rust\nfn main() {\n  let houses = [\\\u201cAtreides\\\u201c, \\\u201cHarkonnen\\\u201c, \\\u201cCorrino\\\u201c];\n  let agendas = [\\\u201cTrade\\\u201c, \\\u201cWar\\\u201c, \\\u201cEspionage\\\u201c];\n\n  // Using nested loops to understand each House's agenda\n  for house in houses.iter() {\n    for agenda in agendas.iter() {\n      println!(\\\u201cHouse {} and their stance on {}.\\\u201c, house, agenda);\n    }\n  }\n}\n```\n\nHere, the nested `for` loops help Paul systematically assess each House's stance on different agendas.",
        "task": "Leveraging the structure provided, implement your own nested `for` loops in a new scenario. Create a situation involving multiple categories and items within those categories. Then, analyze or perform actions on each item in the context of its category within the loops.\n\n```rust\nfn main() {\n  /* TODO: Define your categories and their items */\n  /* TODO: Create nested for loops to work through each category and item */\n}\n```\n\n**Plan:**\n1. Define multiple categories and list items or aspects within those categories.\n2. Construct nested `for` loops to iterate over each item in each category.\n3. Inside the inner loop, perform actions or print statements specific to the category-item combination. Start by defining your categories and items."
      },
      {
        "heading": "Loops with Continue",
        "content": "Just as Paul must sometimes make abrupt decisions to either continue his journey or retreat, loop controls in Rust alter the flow of loops.\n\nPaul is searching for a hidden water cache in the desert:\n\n```rust\nfn main() {\n  let mut distance_traveled = 0;\n\n  while distance_traveled < 10 {\n    distance_traveled += 1;\n\n    if distance_traveled % 2 == 0 {\n      println!(\\\u201cContinuing search...\\\u201c);\n      continue; // Skipping the rest of this iteration\n    }\n\n    println!(\\\u201cSearching at distance: {}\\\u201c, distance_traveled);\n  }\n\n  println!(\\\u201cWater cache found!\\\u201c);\n}\n```\n\nIn this snippet, `continue` skips to the next iteration under certain conditions.",
        "task": "Using the example above as inspiration, write your own loop in Rust that utilizes the `continue` statement. Create a scenario where `continue` helps in skipping certain iterations based on specific conditions.\n\n```rust\nfn main() {\n  /* TODO: Initialize your loop and variables */\n  /* TODO: Implement a loop with conditions that use `continue` to skip iterations */\n}\n```\n\n**Plan:**\n1. Initialize variables and set up a loop structure.\n2. Implement conditions within your loop that trigger the `continue` statement, thus skipping some iterations.\n3. Explain what each part of your loop does, especially the conditions leading to `continue`. Begin by initializing your variables and setting up your loop."
      },
      {
        "heading": "Loops with Break",
        "content": "Like the enduring struggle for Arrakis, infinite loops run indefinitely unless an escape condition is met.\n\nPaul sets up an infinite surveillance loop to guard against sandworm attacks:\n\n```rust\nfn main() {\n  loop {\n    // Check for sandworm activity\n    if check_for_sandworms() {\n      println!(\\\u201cSandworm detected! Initiating defense protocols.\\\u201c);\n      break; // Break out of the loop if a sandworm is detected\n    } else {\n      println!(\\\u201cNo sandworm activity. Continuing surveillance.\\\u201c);\n    }\n  }\n}\n\n// Dummy function to simulate sandworm detection\nfn check_for_sandworms() -> bool {\n  // In a real program, this would involve some condition check\n  // For illustration, it randomly returns true or false\n  rand::random()\n}\n```\n\nHere, an infinite `loop` runs surveillance until `sandworm_alert` becomes true, at which point the loop is exited using `break`.",
        "task": "Inspired by the example, implement your own Rust program featuring an infinite loop with a `break` condition. Create a context where an infinite loop is suitable, and define a clear exit condition.\n\n```rust\nfn main() {\n  /* TODO: Set up an infinite loop with a monitoring or repeating task */\n  /* TODO: Include a break condition to exit the loop */\n}\n```\n\n**Plan:**\n1. Set up an infinite loop that performs a repetitive task or monitoring function.\n2. Define a clear condition under which the loop should be exited, and implement this using `break`.\n3. Optionally, include setup for the condition that triggers the `break`, such as a dummy function or a variable counter. Begin by setting up your infinite loop and defining your break condition."
      },
      {
        "heading": "Simple Pattern Matching",
        "content": "In the intricate world of Dune, the complex societal structures and allegiances require pretty good adaptability, which is where Rust's `match` statements come in handy.\n\nImagine Paul analyzing the loyalties of various factions on Arrakis:\n\n```rust\nfn main() {\n    let faction = \\\u201cFremen\\\u201c;\n\n    let message = match faction {\n        \\\u201cFremen\\\u201c => \\\u201cAllies in the desert.\\\u201c,\n        \\\u201cHarkonnen\\\u201c => \\\u201cEnemies of the Atreides.\\\u201c,\n        \\\u201cBene Gesserit\\\u201c => \\\u201cUnpredictable allies or foes.\\\u201c,\n        _ => \\\u201cUnknown faction.\\\u201c,\n    };\n\n    println!(\\\u201cThe {} are: {}\\\u201c, faction, message);\n}\n```\n\nIn this snippet, the `match` statement allows for complex decision-making based on the value of `faction`, which gives us the power to handle multiple conditions with precision.",
        "task": "Using the example provided as a template, create your own Rust function using a `match` statement to evaluate different conditions. Think of a setting or scenario where multiple outcomes are possible based on a single input.\n\n```rust\nfn main() {\n  /* TODO: Define your variable and match statement */\n  /* TODO: Set up different branches and outcomes in your match statement */\n}\n```\n\n**Plan:**\n1. Define a variable to be used in your `match` statement that reflects your chosen scenario.\n2. Set up a `match` statement with various conditions and corresponding actions or outcomes.\n3. Print out a message or perform an action based on the outcome of the match. Start by defining your variable and the different conditions."
      },
      {
        "heading": "Result Type",
        "content": "The unforgiving landscape of Arrakis demands that Paul anticipates and manages risks, mirroring the way Rust programmers handle potential errors using `Result` type.\n\nConsider Paul sending spies to gather intelligence, where the mission could fail:\n\n```rust\nfn main() {\n    let spy_report = gather_intelligence();\n\n    match spy_report {\n        Ok(info) => println!(\\\u201cIntelligence gathered: {}\\\u201c, info),\n        Err(error) => println!(\\\u201cMission failed: {}\\\u201c, error),\n    }\n}\n\n// Dummy function to simulate gathering intelligence\nfn gather_intelligence() -> Result<String, String> {\n    // Simulation of a situation that could either succeed or fail\n    if rand::random() {\n        Ok(\\\u201cSpice production levels are normal.\\\u201c.to_string())\n    } else {\n        Err(\\\u201cSpy captured by Harkonnen.\\\u201c.to_string())\n    }\n}\n```\n\nHere, the `Result` type is used to handle the possibility of failure in a controlled way, showing how Rust encourages explicit error handling to build reliable software.",
        "task": "Following the pattern in the example, create a new scenario in Rust where you use the `Result` type to handle potential success or failure. Think of a context where a task could either be completed successfully or fail due to an error.\n\n```rust\nfn main() {\n  /* TODO: Set up a scenario that could succeed or fail */\n  /* TODO: Use a match statement to handle the outcomes of your scenario */\n}\n\n// Dummy function to simulate your scenario's success or failure\nfn your_scenario_function() -> Result<String, String> {\n  /* TODO: Implement logic for success or failure */\n}\n```\n\n**Plan:**\n1. Set up a new scenario where a task could result in success or failure.\n2. Implement a function that returns a `Result` type based on the outcome of the scenario.\n3. Use a match statement in the `main` function to handle the possible outcomes of your scenario. Begin by setting up your scenario and implementing your function."
      },
      {
        "heading": "Option Type",
        "content": "The quest for the elusive spice melange on Arrakis often leads to situations where outcomes are uncertain, much like how Rust's `Option` type is used to handle the absence of value in a safe and clear manner.\n\nImagine Paul conducting a search for a hidden spice cache, where the existence of the cache is not guaranteed:\n\n```rust\nfn main() {\n    let spice_cache_location = find_spice_cache();\n\n    match spice_cache_location {\n        Some(location) => println!(\\\u201cSpice cache found at: {}\\\u201c, location),\n        None => println!(\\\u201cNo spice cache found.\\\u201c);\n    }\n}\n\n// Dummy function to simulate searching for a spice cache\nfn find_spice_cache() -> Option<String> {\n    // Simulation of a search that might or might not find a cache\n    if rand::random() {\n        Some(\\\u201ceastern dune sea\\\u201c.to_string())\n    } else {\n        None\n    }\n}\n```\n\nIn this snippet, `Option` is used to represent the outcome of searching for the spice cache. The `Some` variant indicates the cache was found and contains its location, while `None` represents the failure to find the cache.",
        "task": "Using the structure from the provided example, create your own scenario in Rust using the `Option` type to signify the presence or absence of something. This could be a real-world situation or another fictional setting.\n\n```rust\nfn main() {\n  /* TODO: Set up a scenario that could have two outcomes */\n  /* TODO: Use a match statement to handle the outcomes */\n}\n\n// Dummy function to simulate the outcome of your scenario\nfn your_scenario_result() -> Option<String> {\n  /* TODO: Define a condition that leads to Some or None */\n}\n```\n\n**Plan:**\n1. Set up a scenario that could end with a definite outcome or an uncertain one.\n2. Create a function that returns an `Option` type based on the outcome of the scenario.\n3. In the `main` function, use a match statement to address the possible outcomes of your scenario. Start by defining your scenario and creating your function."
      },
      {
        "heading": "If-Let Pattern",
        "content": "In the complex and often ambiguous world of Dune, quick and decisive action based on partial information is vital for survival, much like how `if let` can be used in Rust for a more concise control flow when dealing with enums.\n\nImagine Paul trying to quickly assess the allegiance of a group encountered in the desert:\n\n```rust\nenum Allegiance {\n    Fremen,\n    Harkonnen,\n    Unknown,\n}\n\nfn main() {\n    let encountered_group = Allegiance::Fremen;\n    if let Allegiance::Fremen = encountered_group {\n        println!(\\\u201cThe encountered group are allies.\\\u201c);\n    } else {\n        println!(\\\u201cProceed with caution.\\\u201c);\n    }\n}\n```\n\nThis snippet shows how `if let` can simplify working with enums by focusing on only one pattern and handling it, making the code cleaner and more readable when you're interested in only one of the possible cases.",
        "task": "Inspired by the provided example, utilize `if let` in a Rust program to simplify control flow in a scenario where only one particular outcome out of several is significant. Choose a setting or context where this approach is beneficial, and implement it in your code.\n\n```rust\nfn main() {\n  /* TODO: Define your enum and variable */\n  /* TODO: Use `if let` to handle the significant outcome */\n  /* TODO: Provide alternative action for other cases */\n}\n```\n\n**Plan:**\n1. Define an enum with several variants relevant to your scenario.\n2. Set up a scenario where you check for a specific variant of this enum using `if let`.\n3. Provide an alternative action or output if the condition does not meet the `if let` pattern. Start by defining your enum and setting up your scenario."
      }
    ]
  },
  {
    "order": 2,
    "title": "Enums",
    "subtitle": "With examples from The Matrix",
    "url": "https://medium.com/rustaceans/rust-enums-a-fun-guide-with-examples-f3bb0f590d93?sk=08825ba512c2cf2638c1fa3e177a643a",
    "snippets": [
      {
        "heading": "The Basics of Enums",
        "content": "An Enum is a type that can be any one of several variants. It\u2019s similar to how Neo must understand his identity: is he Thomas Anderson, a regular software engineer, or Neo, the chosen one?\n\nImagine a scenario where Morpheus offers Neo a choice between two pills.\n\n```rust\nenum Pill {\n    Red,\n    Blue,\n}\n\nfn main() {\n  let choice = Pill::Red; // Neo chooses the Red pill\n  match choice {\n    Pill::Red => println!(\\\u201cWelcome to the real world.\\\u201c),\n    Pill::Blue => println!(\\\u201cStay in the dream.\\\u201c),\n  }\n}\n```\n\nHere, the `Pill` enum has two variants: `Red` and `Blue`. Neo's choice is represented by one of these variants. The `match` statement then acts like Morpheus, interpreting Neo's decision.",
        "task": "Given the following code snippet, complete the missing parts of the code where indicated by '/* TODO: */'. You need to add another variant to the `Pill` enum and handle it in the `match` statement.\n\n```rust\nenum Pill {\n    Red,\n    Blue,\n    /* TODO: Add another variant here */\n}\n\nfn main() {\n  let choice = /* TODO: Assign your new variant as the choice */\n  match choice {\n    Pill::Red => println!(\\\u201cWelcome to the real world.\\\u201c),\n    Pill::Blue => println!(\\\u201cStay in the dream.\\\u201c),\n    /* TODO: Add a match arm for your new variant */\n  }\n}\n```\n\n**Plan:**\n1. Declare a new variant for the `Pill` enum.\n2. Assign the new variant to `choice` in the `main` function.\n3. Add a new match arm in the `match` statement to handle your new variant. Start with the first step."
      },
      {
        "heading": "Enums with Data",
        "content": "Enums in Rust can also hold data, much like how characters in \u201cThe Matrix\u201d possess unique abilities and attributes.\n\nWe can use an enum to represent different agents with distinct powers.\n\n```rust\nenum Agent {\n  Smith { strength: u32 },\n  Brown { speed: u32 },\n}\n\nfn main() {\n  let agent = Agent::Smith { strength: 100 };\n\n  match agent {\n    Agent::Smith { strength } => println!(\\\u201cAgent Smith with strength: {}\\\u201c, strength),\n    Agent::Brown { speed } => println!(\\\u201cAgent Brown with speed: {}\\\u201c, speed),\n  }\n}\n```\n\nIn this example, each variant of the `Agent` enum carries different data (`strength` for Smith and `speed` for Brown).",
        "task": "Based on the following skeleton, add a new `Agent` variant with a different attribute and update the `match` statement to handle it.\n\n```rust\nenum Agent {\n  Smith { strength: u32 },\n  Brown { speed: u32 },\n  /* TODO: Add another variant with a different attribute */\n}\n\nfn main() {\n  let agent = /* TODO: Create an instance of your new variant */;\n\n  match agent {\n    Agent::Smith { strength } => println!(\\\u201cAgent Smith with strength: {}\\\u201c, strength),\n    Agent::Brown { speed } => println!(\\\u201cAgent Brown with speed: {}\\\u201c, speed),\n    /* TODO: Add a new match arm for your variant */\n  }\n}\n```\n\n**Plan:**\n1. Define a new variant for the `Agent` enum that holds a unique data type.\n2. Instantiate this new variant in the `main` function.\n3. Implement a new match arm in the `match` statement to process this new variant. Start by defining the new variant."
      },
      {
        "heading": "Methods in Enums",
        "content": "Just as Neo learns to control his abilities in \u201cThe Matrix\u201d, methods can be defined on enums to perform actions based on their variants.\n\nNeo\u2019s choice of the pill has a significant impact on his journey.\n\n```rust\nenum Pill {\n  Red,\n  Blue,\n}\n\nimpl Pill {\n  fn take_action(&self) {\n    match self {\n      Pill::Red => println!(\\\u201cYou've chosen the path of truth.\\\u201c),\n      Pill::Blue => println!(\\\u201cYou've chosen the path of blissful ignorance.\\\u201c),\n    }\n  }\n}\n\nfn main() {\n  let my_choice = Pill::Red;\n  my_choice.take_action();\n}\n```\nHere, the `take_action` method is implemented on the Pill enum using `impl`. It interprets the choice made, similar to how Neo's decision shapes his destiny.",
        "task": "Modify the following Rust code skeleton to add a new method to the `Pill` enum that describes the consequences of the choice. Implement the method and call it in `main`.\n\n```rust\nenum Pill {\n  Red,\n  Blue,\n}\n\nimpl Pill {\n  fn take_action(&self) {\n    // existing code\n  }\n  /* TODO: Define a new method that prints a message about the consequences of the choice */\n}\n\nfn main() {\n  let my_choice = Pill::Red;\n  my_choice.take_action();\n  /* TODO: Call your new method here */\n}\n```\n\n**Plan:**\n1. Add a new method to the `Pill` enum inside the `impl` block.\n2. Write logic inside this method to output a consequence based on the pill chosen.\n3. In the `main` function, create an instance of `Pill` and call this new method after `take_action`. Start with the first step."
      },
      {
        "heading": "Option handling with enums",
        "content": "The `Option` enum is one of the pre-made enums in Rust that are used frequently and are very useful. It can represent either `Some` value or `None`.\n\nWe can compare the `Option`to Neo's potential to have `Some` title (in his case, it would be 'The One') or `None`.\n\n```rust\nfn main() {\n  let neo: Option<&str> = Some(\\\u201cThe One\\\u201c);\n\n  match neo {\n    Some(title) => println!(\\\u201cNeo is {}\\\u201c, title),\n    None => println!(\\\u201cNeo is just another human.\\\u201c),\n  }\n}\n```\nThis snippet uses `Option` to capture the uncertainty of Neo's true identity, showcasing how Rust's enums can express the presence or absence of a value.",
        "task": "In the provided Rust code template, modify the use of the `Option` enum to represent a different scenario where a character may or may not have a certain ability. Then, use a match statement to handle both cases.\n\n```rust\nfn main() {\n  let character: Option<&str> = /* TODO: Set to Some with an ability or None */;\n\n  match character {\n    Some(ability) => println!(\\\u201cThe character has {}\\\u201c, ability),\n    None => println!(\\\u201cThe character has no special abilities.\\\u201c),\n  }\n}\n```\n\n**Plan:**\n1. Change `character`'s value from Neo's title to a character ability or lack thereof.\n2. Adjust the match statement to reflect the new context of abilities instead of titles.\n3. Test the function with different values for `character`. Start with changing the `character`'s value."
      },
      {
        "heading": "Error handling with enums",
        "content": "Just as characters in \u201cThe Matrix\u201c experience glitches, our code is not resistant to problems either. That's why proper error handling is crucial. Fortunately in Rust, we can elegantly represent possible error states with enums.\n\nConsider a scenario where Neo tries to access a secure database but encounters various errors.\n\n```rust\nenum DatabaseError {\n  ConnectionLost,\n  AccessDenied,\n  NotFound,\n}\n\nfn access_database() -> Result<String, DatabaseError> {\n  if rand::random() {\n      Ok(\\\u201cYou are in.\\\u201c.to_string())\n    } else {\n      // Access might be randomly denied\n      Err(DatabaseError::AccessDenied)\n    }\n}\n\nfn main() {\n  match access_database() {\n      Ok(data) => println!(\\\u201cData retrieved: {}\\\u201c, data),\n      Err(DatabaseError::ConnectionLost) => println!(\\\u201cError: Connection lost.\\\u201c),\n      Err(DatabaseError::AccessDenied) => println!(\\\u201cError: Access denied.\\\u201c),\n      Err(DatabaseError::NotFound) => println!(\\\u201cError: Data not found.\\\u201c),\n  }\n}\n```\n\nThe `DatabaseError` enum defines different error types that can occur. The `access_database` function, instead of returning data directly, returns a `Result` type, which is a pre-made enum that can be:\n\n-   `Ok` containing successful data,\n-   `Err` containing error data, which in our case would be an enum variant of `DatabaseError`.\n\nThe `match` statement in the `main` function handles these potential errors, similar to how Neo and his allies adapt to the challenges they face.",
        "task": "In the given Rust code skeleton, implement a new error handling scenario for a different function. Modify the `DatabaseError` enum to include a new type of error, then create a function that can return this new error. Update the `match` statement in `main` to handle this new error type.\n\n```rust\nenum DatabaseError {\n  ConnectionLost,\n  AccessDenied,\n  NotFound,\n  /* TODO: Add a new error type */\n}\n\nfn new_function() -> Result<String, DatabaseError> {\n  // Implement your logic here that might return the new error\n}\n\nfn main() {\n  match new_function() {\n      /* TODO: Handle the new error type along with the existing ones */\n  }\n}\n```\n\n**Plan:**\n1. Add a new error type to the `DatabaseError` enum.\n2. Write a new function that can return a `Result` type including your new error.\n3. Expand the `match` statement in `main` to handle this new error along with the existing ones. Start by adding the new error type to the `DatabaseError` enum."
      },
      {
        "heading": "Enums with Match Guards",
        "content": "Match guards give us the power to do some sensible decision-making processes within enums.\n\nLet's illustrate this with an example where Neo faces different scenarios based on his health status.\n\n```rust\nenum Scenario {\n  Battle,\n  Exploration,\n}\n\nfn match_guard(health: u32) -> Scenario {\n  match health {\n    h if h > 50 => Scenario::Battle,\n    _ => Scenario::Exploration,\n  }\n}\n\nfn main() {\n  let neo_health = 30;\n  let scenario = match_guard(neo_health);\n\n  match scenario {\n    Scenario::Battle => println!(\\\u201cNeo chooses to fight.\\\u201c),\n    Scenario::Exploration => println!(\\\u201cNeo chooses to explore.\\\u201c),\n  }\n}\n```\n\nThe `choose_scenario` function uses a match guard (`h if h > 50`) to decide the scenario based on Neo's health. If Neo's health is above 50, he chooses to fight. Otherwise, he opts for exploration.",
        "task": "Using the structure provided, create a new function with match guards that evaluates a different condition. Implement this with a new enum to handle different outcomes.\n\n```rust\nenum NewScenario {\n  /* TODO: Define new scenarios */\n}\n\nfn new_match_guard(/* TODO: Define new condition */) -> NewScenario {\n  /* TODO: Implement match guards based on the new condition */\n}\n\nfn main() {\n  /* TODO: Set a new condition, call your new function and use match to handle the outcomes */\n}\n```\n\n**Plan:**\n1. Define new scenarios in your `NewScenario` enum.\n2. Create a function that uses match guards to return different `NewScenario` variants based on a new condition.\n3. In the `main` function, set up a condition, call your function, and use a match statement to act on the returned scenario. Start by defining your new scenarios within the `NewScenario` enum."
      },
      {
        "heading": "Enums with Generics",
        "content": "Generics in Rust provide the flexibility to write code that can operate on different data types. When combined with enums, generics allow us to define more versatile and reusable structures.\n\nLet's create an enum that can hold different data types, reflecting the diverse nature of the Matrix.\n\n```rust\nenum MatrixEntity<T, U> {\n  Human(T),\n  Program(U),\n}\n\nfn main() {\n  let neo: MatrixEntity<&str, &str> = MatrixEntity::Human(\\\u201cThe One\\\u201c);\n  let smith: MatrixEntity<i32, &str> = MatrixEntity::Program(\\\u201cAgent Smith\\\u201c);\n\n  match neo {\n    MatrixEntity::Human(name) => println!(\\\u201cNeo is known as {}\\\u201c, name),\n    MatrixEntity::Program(_) => println!(\\\u201cIt's a program, not Neo\\\u201c),\n  }\n\n  match smith {\n    MatrixEntity::Human(_) => println!(\\\u201cIt's a human, not an agent\\\u201c),\n    MatrixEntity::Program(name) => println!(\\\u201cProgram {} identified\\\u201c, name),\n  }\n}\n```\n\nNotice that `MatrixEntity` is a generic enum that can represent a human or a program, using different combinations of data types for each variant. `T` and `U` are generic type parameters that make the enum flexible and reusable for various types.",
        "task": "Adapt the provided code structure to create a new generic enum that represents different elements in a new context, not necessarily related to the Matrix. Then, create instances of this enum with different data types and use a match statement to handle them in `main`.\n\n```rust\nenum NewGenericEnum<A, B> {\n  /* TODO: Define new variants with generics */\n}\n\nfn main() {\n  /* TODO: Create instances of your new enum with different data types and handle them with match */\n}\n```\n\n**Plan:**\n1. Define a new generic enum with at least two variants, each taking different generic types.\n2. In the `main` function, create instances of this new enum using different types for each variant.\n3. Implement match statements to handle the different instances based on their variant. Begin by defining the variants for your new generic enum."
      },
      {
        "heading": "Enum Forwarding with Delegation",
        "content": "Enums can delegate responsibilities to their variants, a technique that mirrors the way different characters in \u201cThe Matrix\u201c might take on specific roles or actions. This delegation can be implemented using traits and the `impl` keyword, allowing each variant of an enum to behave differently under the same method call.\n\nLet's illustrate this with an example where different characters in the Matrix have unique responses to a situation.\n\n```rust\ntrait Action {\n  fn act(&self);\n}\n\nenum Character {\n  Neo,\n  Morpheus,\n  Trinity,\n}\n\nimpl Action for Character {\n  fn act(&self) {\n    match self {\n      Character::Neo => println!(\\\u201cNeo chooses to fight.\\\u201c),\n      Character::Morpheus => println!(\\\u201cMorpheus offers wisdom.\\\u201c),\n      Character::Trinity => println!(\\\u201cTrinity hacks the system.\\\u201c),\n    }\n  }\n}\n\nfn main() {\n  let character = Character::Trinity;\n  character.act();\n}\n```\n\nThe `Action` trait defines an `act` method. Each character variant implements this method differently, signifying their unique response or action.",
        "task": "Refactor the provided code to include a new enum variant and extend the `Action` trait implementation to cover this new character. Additionally, test this new implementation in the `main` function.\n\n```rust\nenum Character {\n  Neo,\n  Morpheus,\n  Trinity,\n  /* TODO: Add a new character */\n}\n\nimpl Action for Character {\n  fn act(&self) {\n    // existing implementation\n    /* TODO: Add action for the new character */\n  }\n}\n\nfn main() {\n  /* TODO: Create an instance of the new character and call act() */\n}\n```\n\n**Plan:**\n1. Add a new character variant to the `Character` enum.\n2. Extend the `Action` trait implementation to include an action for this new character.\n3. In the `main` function, instantiate this new character and call the `act` method. Begin by adding the new character to the enum."
      },
      {
        "heading": "Enums in State Design Pattern",
        "content": "Enums in Rust can be leveraged to implement the State design pattern, mirroring the dynamic changes in the Matrix.\n\nJust as characters in \u201cThe Matrix\u201c transition between different states of awareness and capability, software components can change their behavior based on their state, without altering their type. Enums facilitate this by encapsulating the different possible states and behaviors into variants.\n\n```rust\nenum MatrixState {\n    RealWorld,\n    MatrixSimulation,\n}\n\nimpl MatrixState {\n    fn switch(&self) -> MatrixState {\n        match self {\n            MatrixState::RealWorld => MatrixState::MatrixSimulation,\n            MatrixState::MatrixSimulation => MatrixState::RealWorld,\n        }\n    }\n}\n\nfn main() {\n    let current_state = MatrixState::RealWorld;\n    let new_state = current_state.switch();\n    // new_state is now MatrixSimulation\n}\n```\n\nNeo transitions between the real world and the Matrix simulation, similar to how enums can elegantly handle state transitions in Rust.",
        "task": "Use the example as a guide to create a new enum representing different states in another context (e.g., a game, a workflow, etc.). Implement a method for this enum that transitions between its states. Then, demonstrate this transition in the `main` function.\n\n```rust\nenum NewStateEnum {\n  /* TODO: Define different states */\n}\n\nimpl NewStateEnum {\n  fn transition(&self) -> NewStateEnum {\n    /* TODO: Implement state transition logic */\n  }\n}\n\nfn main() {\n  let current_state = /* TODO: Initialize with one of the states */;\n  let new_state = current_state.transition();\n  // Demonstrate the transition\n}\n```\n\n**Plan:**\n1. Create a new enum with different states relevant to your new context.\n2. Implement a method for this enum that allows for transitioning between its states.\n3. In the `main` function, initialize an instance of your enum in one state, transition to another, and print out both states. Begin by defining the states in your new enum."
      },
      {
        "heading": "Recursive Enums",
        "content": "Recursive enums allow for the definition of data structures that can contain themselves. This is particularly useful for creating tree-like structures, such as abstract syntax trees in compilers or various hierarchical models.\n\n```rust\nenum MatrixComponent {\n    Node(String, Vec<MatrixComponent>),\n    Leaf(String),\n}\n\nfn main() {\n    let system = MatrixComponent::Node(\\\u201cRoot\\\u201c.to_string(), vec![\n        MatrixComponent::Leaf(\\\u201cLeaf 1\\\u201c.to_string()),\n        MatrixComponent::Node(\\\u201cNode 1\\\u201c.to_string(), vec![\n            MatrixComponent::Leaf(\\\u201cLeaf 2\\\u201c.to_string()),\n            MatrixComponent::Leaf(\\\u201cLeaf 3\\\u201c.to_string()),\n        ]),\n    ]);\n    // We now have a recursive enum that contains itself over and over...\n}\n```\n\nThis example represents a hierarchical structure (using a recursive enum) such as the layered reality of the Matrix.",
        "task": "Utilizing the structure of the provided example, create your own recursive enum to represent a different hierarchical system, such as a file system or an organization structure. Implement a sample instance of this structure in the `main` function.\n\n```rust\nenum YourRecursiveEnum {\n  /* TODO: Define your recursive structure */\n}\n\nfn main() {\n  let structure = /* TODO: Create a sample instance of your structure */;\n  // Build your recursive system here\n}\n```\n\n**Plan:**\n1. Define a new recursive enum suitable for your chosen hierarchical system.\n2. In the `main` function, construct an instance of this new recursive structure, demonstrating how it can contain instances of itself.\n3. Comment on the design choices you made in building this structure. Begin by defining your recursive enum."
      }
    ]
  },
  {
    "order": 3,
    "title": "Structs",
    "subtitle": "With examples from The Game of Thrones",
    "url": "https://medium.com/rustaceans/rust-structs-a-fun-guide-with-examples-c2851dfb96c6?sk=a1493ed9de65e20c38aa7960d4312588",
    "snippets": [
      {
        "heading": "The Basics of Structs",
        "content": "When we want to group related values, structs come really handy.\n\nFor example, we can define each great house in the *Game of Thrones* with some specific attributes, such as name and region.\n\n```rust\nstruct House {\n  name: String,\n  region: String,\n}\n\nfn main() {\n  let house_stark = House {\n    name: String::from(\\\u201cStark\\\u201c),\n    region: String::from(\\\u201cThe North\\\u201c),\n  };\n\n  println!(\\\u201cHouse {} of {}\\\u201c, house_stark.name, house_stark.region);\n}\n```\n\nWe defined a noble house in Westeros as a `House` struct with fields for `name` and `region`.",
        "task": "Following the pattern from the example, create your own Rust struct to represent another type of object or entity, relevant to a different context or theme. Then, instantiate this struct in the `main` function and print out its properties.\n\n```rust\nstruct YourStruct {\n  /* TODO: Define the fields for your struct */\n}\n\nfn main() {\n  let your_instance = YourStruct {\n    /* TODO: Initialize your struct with values */\n  };\n\n  /* TODO: Print out the properties of your instance */\n}\n```\n\n**Plan:**\n1. Define your own struct with relevant fields for the scenario you choose.\n2. Instantiate your struct with specific values in the `main` function.\n3. Print out the properties of your struct instance. Begin by defining the fields for your struct."
      },
      {
        "heading": "Methods in Structs",
        "content": "Each house has some specific behavior. We can define those with methods.\n\nLet's say that each house can rally its bannermen for aid. We will implement this action as a method of the `House` struct while adding the number of bannerman as another field in the `House` struct.\n\n```rust\nstruct House {\n  name: String,\n  region: String,\n  bannermen: u32,\n}\n\nimpl House {\n  fn rally_bannermen(&mut self, additional: u32) {\n    self.bannermen += additional;\n    println!(\\\u201cHouse {} now has {} bannermen.\\\u201c, self.name, self.bannermen);\n  }\n}\n\nfn main() {\n  let mut house_arryn = House {\n    name: String::from(\\\u201cArryn\\\u201c),\n    region: String::from(\\\u201cThe Vale\\\u201c),\n    bannermen: 500,\n  };\n\n  house_arryn.rally_bannermen(300);\n}\n```\n\nIn the example above, the `House Arryn` can use the `rally_bannermen` method to increase the number of its bannermen.",
        "task": "Inspired by the given example, create your own Rust struct with a method that changes one of its fields. Design the scenario based on your own interest or a different fictional context. Then, instantiate this struct and use its method in the `main` function.\n\n```rust\nstruct YourStruct {\n  /* TODO: Define fields */\n}\n\nimpl YourStruct {\n  /* TODO: Define a method that modifies one of the fields */\n}\n\nfn main() {\n  let mut your_instance = YourStruct {\n    /* TODO: Initialize your struct */\n  };\n\n  /* TODO: Use the method you defined to modify the instance */\n}\n```\n\n**Plan:**\n1. Define a struct with at least one field that can be changed.\n2. Implement a method within this struct that changes the value of that field.\n3. In the `main` function, create an instance of your struct and use the method to modify its field. Start by defining the fields of your struct."
      },
      {
        "heading": "Associated Functions",
        "content": "Associated functions represent the cold face of a house shown to strangers. They are related to a struct but don't use information of the struct and neither update the struct.\n\nCreating a new house in Westeros is a significant event and can be represented as an associated function. Notice that the `found_new_house` function has neither the `&self` nor `&mut self` parameter --- so it's not a method but just an associated function.\n\n```rust\nstruct House {\n  name: String,\n  region: String,\n  bannermen: u32,\n}\n\nimpl House {\n  fn found_new_house(name: String, region: String) -> House {\n    House {\n      name,\n      region,\n      bannermen: 100, // Default number of bannermen for a new house\n    }\n  }\n}\n\nfn main() {\n  let house_tarly = House::found_new_house(\n    String::from(\\\u201cTarly\\\u201c),\n    String::from(\\\u201cThe Reach\\\u201c),\n  );\n  println!(\\\u201cHouse {} of {} has been founded.\\\u201c, house_tarly.name, house_tarly.region);\n}\n```\n\nThe function `found_new_house` is associated with the `House` struct now. It creates a new house with a default bannermen number, but it neither reads any info from a `House` and neither updates an existing `House`.\n\nCore differences between struct methods and associated functions:\n\n-   Associated functions don't receive the `&self` / `&mut self` argument, so they don't have access to the struct's properties, but struct methods do.\n-   Associated functions are called with the `::` notation as opposed to struct methods which are called with the `.` notation.",
        "task": "Using the provided example as a template, create your own Rust struct and define an associated function for it. This function should not require access to the struct's instance data, and it should create or perform some operation relevant to the struct. Then, use this associated function in the `main` function.\n\n```rust\nstruct YourStruct {\n  /* TODO: Define struct fields */\n}\n\nimpl YourStruct {\n  fn your_associated_function(/* TODO: Define parameters */) -> YourStruct {\n    /* TODO: Implement the function to create or perform an operation */\n  }\n}\n\nfn main() {\n  let your_instance = YourStruct::your_associated_function(/* TODO: Provide arguments */);\n  /* TODO: Perform actions or print out results */\n}\n```\n\n**Plan:**\n1. Define a new struct relevant to your chosen theme or scenario.\n2. Create an associated function for this struct that performs a creation or other relevant operation.\n3. In the `main` function, create an instance of your struct using this associated function and then perform actions or display the results. Start by defining your struct and its associated function."
      },
      {
        "heading": "Structs with Enums",
        "content": "Just as houses have complex structures, so too can Rust structs incorporate enums for added flexibility. Enums in Rust allow us to define a type by enumerating its possible variants. This will be useful when dealing with properties that can have one out of a set of possible values.\n\nLet's introduce an enum to represent the current state of a house in Westeros, such as at peace or war. This enum, named `HouseState`, can then be incorporated into our `House` struct.\n\n```rust\n#[derive(Debug)]\nenum HouseState {\n  AtPeace,\n  AtWar,\n}\n\nstruct House {\n  name: String,\n  region: String,\n  bannermen: u32,\n  state: HouseState,\n}\n\nimpl House {\n  fn change_state(&mut self, new_state: HouseState) {\n      self.state = new_state;\n  }\n}\n\nfn main() {\n  let mut house_lannister = House {\n      name: String::from(\\\u201cLannister\\\u201c),\n      region: String::from(\\\u201cThe Westerlands\\\u201c),\n      bannermen: 1000,\n      state: HouseState::AtPeace,\n  };\n\n  house_lannister.change_state(HouseState::AtWar);\n\n  println!(\\\u201cHouse {} is now {:?}\\\u201c, house_lannister.name, house_lannister.state);\n}\n```\n\nThe first line, `#[derive(Debug)]`, is there just so that Rust knows how to print the enum value with `println!` at the end of the `main` function.\n\nThe important thing here is that we defined the `HouseState` enum with two variants. Each `House` struct now also includes a `state` field of type `HouseState`. The method `change_state` allows a house to change its state, reflecting dynamic political scenarios in Westeros.",
        "task": "Following the example, design your own Rust struct which includes an enum to represent variable aspects of the entity. Then, include a method in your struct to change the state of this enum. In the `main` function, instantiate your struct, change its state using the method, and print the result.\n\n```rust\n#[derive(Debug)]\nenum YourEnum {\n  /* TODO: Define possible states */\n}\n\nstruct YourStruct {\n  /* TODO: Define fields including an enum field */\n}\n\nimpl YourStruct {\n  fn change_state(&mut self, new_state: YourEnum) {\n    /* TODO: Change the enum state */\n  }\n}\n\nfn main() {\n  let mut your_instance = YourStruct {\n    /* TODO: Initialize your struct */\n  };\n  your_instance.change_state(/* TODO: Provide a new state */);\n  println!(\\\u201cYour instance is now {:?}\\\u201c, your_instance);\n}\n```\n\n**Plan:**\n1. Define an enum with different states relevant to your struct.\n2. Create a struct that includes this enum as a field.\n3. Implement a method in your struct to change the state of the enum.\n4. Instantiate your struct, change its state using the method, and print the updated state in the `main` function. Begin by defining your enum and struct fields."
      },
      {
        "heading": "Structs with Traits",
        "content": "Just as each house has its unique traits, we can define traits to encapsulate shared behaviors across different Rust structs. Traits in Rust are similar to interfaces in other languages; they define a set of methods that can be implemented by structs.\n\nLet's define a trait `HouseTraits` that represents common actions of a noble house, such as hosting a feast or defending its lands. This trait can then be implemented by our `House` struct.\n\n```rust\n#[derive(Debug)]\nenum HouseState {\n  AtPeace,\n  AtWar,\n}\n\nstruct House {\n  name: String,\n  region: String,\n  bannermen: u32,\n  state: HouseState,\n}\n\ntrait HouseTraits {\n  fn host_feast(&self);\n  fn defend_lands(&mut self, additional_bannermen: u32);\n}\n\nimpl HouseTraits for House {\n  fn host_feast(&self) {\n      println!(\\\u201cHouse {} is hosting a grand feast!\\\u201c, self.name);\n  }\n\n  fn defend_lands(&mut self, additional_bannermen: u32) {\n      self.bannermen += additional_bannermen;\n      println!(\\\u201cHouse {} defends its lands with {} bannermen.\\\u201c, self.name, self.bannermen);\n  }\n}\n\nfn main() {\n  let mut house_baratheon = House {\n      name: String::from(\\\u201cBaratheon\\\u201c),\n      region: String::from(\\\u201cThe Stormlands\\\u201c),\n      bannermen: 800,\n      state: HouseState::AtWar,\n  };\n\n  house_baratheon.host_feast();\n  house_baratheon.defend_lands(200);\n}\n```\n\nIn this example, the `HouseTraits` trait includes two methods: `host_feast`, which is a read-only action, and `defend_lands`, which modifies the state of the struct. The `House` struct then implements these methods, providing specific behaviors.\n\nCore differences between struct methods and traits:\n\n-   struct methods are specific to a particular struct,\n-   traits define a set of methods that can be implemented by multiple types (including structs)",
        "task": "Inspired by the example, define your own trait and struct in Rust. The trait should include at least two actions relevant to your struct's context. Implement the trait for your struct, then instantiate the struct and use the trait methods in the `main` function.\n\n```rust\n#[derive(Debug)]\nenum YourEnum {\n  /* TODO: Define states or types */\n}\n\nstruct YourStruct {\n  /* TODO: Define fields */\n}\n\ntrait YourTrait {\n  fn action_one(&self);\n  fn action_two(&mut self, value: u32);\n}\n\nimpl YourTrait for YourStruct {\n  fn action_one(&self) {\n    /* TODO: Implement action */\n  }\n  fn action_two(&mut self, value: u32) {\n    /* TODO: Implement action that changes state */\n  }\n}\n\nfn main() {\n  let mut your_instance = YourStruct {\n    /* TODO: Initialize your struct */\n  };\n  your_instance.action_one();\n  your_instance.action_two(/* TODO: Provide a value */);\n}\n```\n\n**Plan:**\n1. Define an enum (if needed) and a struct relevant to your scenario.\n2. Create a trait with actions that make sense for your struct.\n3. Implement this trait for your struct, providing specific behaviors for each action.\n4. In the `main` function, create an instance of your struct and demonstrate the use of the trait methods. Start by defining your struct and its trait."
      }
    ]
  },
  {
    "order": 4,
    "title": "Strings",
    "subtitle": "With examples from The Witcher",
    "url": "https://medium.com/rustaceans/rust-strings-a-fun-guide-with-examples-e412ff963465?sk=f7c6a09b38b4f3b2de76945cd16ae40a",
    "snippets": [
      {
        "heading": "Creating Strings",
        "content": "In Rust, strings are a bit like the diverse languages spoken across the Continent in The Witcher. They come in various forms, each with unique characteristics.\n\nImagine creating a lexicon for Geralt, containing various terms and phrases he encounters in his journey.\n\n```rust\nfn main() {\n  // Create an empty string\n  let mut lexicon = String::new();\n\n  // The string is empty\n  println!(\\\u201cOpening an empty lexicon {}\\\u201c, lexicon);\n\n  // Convert a string literal to a String\n  let phrase = \\\u201cWitcher\\\u201c;\n  lexicon = phrase.to_string();\n\n  // Print the String\n  println!(\\\u201cGeralt's profession: {}\\\u201c, lexicon);\n\n  // Print the length of the String\n  println!(\\\u201cNumber of characters: {}\\\u201c, lexicon.len());\n\n  // Define a String using `from` method\n  let bestiary = String::from(\\\u201cGriffin\\\u201c);\n\n  // Print the String\n  println!(\\\u201cMonster in the Bestiary: {}\\\u201c, bestiary);\n\n  // Print the length of the String\n  println!(\\\u201cBestiary length: {}\\\u201c, bestiary.len());\n}\n```\n\nAs you can see, we used three ways to create a `String`:\n\n-   `String::new()` to create an empty `String`,\n-   `.to_string()` to convert a string slice to a `String`,\n-   `String::from()` to create a `String` from an un-named string slice (string literal).",
        "task": "Using the example provided, try creating strings in Rust using different methods in your own program. You can consider making a small collection of items, phrases, or concepts relevant to your interest or a chosen theme. Demonstrate each method of string creation, then print out the strings along with their lengths.\n\n```rust\nfn main() {\n  // TODO: Create strings using different methods\n  // TODO: Print out the strings and their lengths\n}\n```\n\n**Plan:**\n1. Use `String::new()` to create an empty string.\n2. Convert a string literal to a `String` using `.to_string()`.\n3. Create a `String` from a string literal using `String::from()`.\n4. Print out each string and its length after creation. Start by creating strings using different methods."
      },
      {
        "heading": "String Types",
        "content": "There are three crucial terms we have used in the previous section: `String`, `string slice`, and `string literal`. That might be a bit confusing in the beginning. Let's explore their differences.\n\n**String**\n\nIn Rust, when we say string, we usually mean the type `String`. It is like a story told around a campfire in The Witcher's world. It's dynamic, can change over time, and grow as more details are added. Just like how Geralt can add more tales to his adventures, we can add more text to a `String`.\n\n```rust\nfn main() {\n    let mut story = String::from(\\\u201cGeralt rode through the dark forest\\\u201c);\n\n    // Geralt's story is growing as he encounters a Leshen\n    story.push_str(\\\u201c, facing the eerie Leshen\\\u201c);\n    println!(\\\u201cCampfire story: {}\\\u201c, story); // Prints the growing story\n}\n```\n\nIn this example, `story` is a mutable `String` type, which means it can be modified after it has been created. We start with Geralt riding through a forest and then add another sentence about an encounter, making the story longer.\n\n**String Slice**\n\nA string slice in Rust is of the type `&str` and it is like a part of the campfire story. It's a reference to a section of the story, not the whole thing. Imagine if you only want to talk about the part where Geralt faces the Leshen, not the entire journey.\n\n```rust\nfn main() {\n    let full_story = String::from(\n        \\\u201cGeralt rode through the dark forest, facing the eerie Leshen\\\u201c,\n    );\n\n    // Slicing the story from the 38th character to the end\n    let part_of_story = &full_story[37..];\n\n    // Prints the slice of the story\n    println!(\\\u201cPart of the story: {}\\\u201c, part_of_story);\n}\n```\n\nHere, `part_of_story` is a slice of `full_story`. It doesn't contain the whole story but just a fragment, specifically the encounter with the Leshen. Unlike the whole story (`String`), this is just a reference to a part of the original --- and as such cannot be changed.\n\n**String Literal**\n\nFinally, a string literal in Rust is also of the type `&str`, but it is more like a story that has been written down into a chronicle in The Witcher's world. It is fixed and cannot be changed --- immutable and eternal.\n\n```rust\nfn main() {\n    // This story is set in stone\n    let written_story = \\\u201cGeralt's adventures are known across the lands.\\\u201c;\n\n    // Prints the string literal\n    println!(\\\u201cWritten story: {}\\\u201c, written_story);\n}\n```\n\nThis `written_story` is a string literal, which means it's a fixed-size string and lives for the entire duration of the program. It's like a tale that has been engraved into history, unchanging and always accessible.",
        "task": "Based on the explanations provided, practice using the different string types in Rust by writing your own code snippet. Define a `String`, a string slice, and a string literal in a small Rust program. Manipulate the `String`, reference a section of it for your slice, and print out your literal. Illustrate the differences between these types through your examples.\n\n```rust\nfn main() {\n  // TODO: Declare and use a String, a string slice, and a string literal\n}\n```\n\n**Plan:**\n1. Create a mutable `String` and add some text to it.\n2. Create a string slice from the `String`.\n3. Define a string literal.\n4. Print all three to demonstrate their usage and differences. Begin by creating a mutable `String`."
      },
      {
        "heading": "String Methods",
        "content": "So we have established that only the type `String` can be changed. Let's now look at the most important options we have for changing it.\n\nImagine that Geralt wants to update his lexicon with more details. Notice which String methods he might use:\n\n```rust\nfn main() {\n  let mut lexicon = String::from(\\\u201cWitcher, \\\u201c);\n\n  // Check if the lexicon contains a specific word\n  if lexicon.contains(\\\u201cGriffin\\\u201c) {\n    println!(\\\u201cGriffin is already in the lexicon.\\\u201c);\n  } else {\n    lexicon.push_str(\\\u201cthe Griffin slayer, \\\u201c);\n  }\n\n  // Replace a word in the lexicon\n  lexicon = lexicon.replace(\\\u201cWitcher\\\u201c, \\\u201cGeralt of Rivia\\\u201c);\n\n  // Trim any extra spaces\n  let trimmed_lexicon = lexicon.trim();\n\n  // Check if the lexicon starts with a specific word\n  if trimmed_lexicon.starts_with(\\\u201cGeralt\\\u201c) {\n    println!(\\\u201cThe lexicon starts with Geralt's name.\\\u201c);\n  }\n\n  // Adding the details of Geralt's adventures\n  lexicon.push_str(\\\u201cis now resting in an inn.\\\u201c);\n\n  // Print the updated lexicon\n  println!(\\\u201cUpdated Lexicon: {}\\\u201c, lexicon);\n}\n```\n\nWe can update the lexicon using methods like `contains`, `push_str`, `replace`, and `trim`. Each method is a tool in your arsenal, much like swords and potions for Geralt.",
        "task": "Following the example, use the different `String` methods to manipulate a `String` in your own Rust program. Create a scenario where you would need to check for a word, append text, replace words, and trim spaces in a string. Show how each method affects the string.\n\n```rust\nfn main() {\n  // TODO: Create and manipulate a String using methods like contains, push_str, replace, and trim\n}\n```\n\n**Plan:**\n1. Initialize a mutable `String` and add initial text to it.\n2. Use `contains` to check for the presence of a specific word.\n3. Append more text with `push_str`.\n4. Replace a word using `replace`.\n5. Trim spaces using `trim`.\n6. Print the final `String` to show how it has changed. Begin by creating a mutable `String` and adding some initial text."
      },
      {
        "heading": "Methods for updating Strings",
        "content": "Like Geralt upgrades his gear and potions, you can add, modify, or remove characters from strings.\n\nUsing those options, Geralt decides to update his potion recipe.\n\n```rust\nfn main() {\n    let mut recipe = String::from(\\\u201cSwallow: \\\u201c);\n\n    // Adding ingredients to the potion\n    recipe.push_str(\\\u201cCelandine, \\\u201c);\n    recipe.push_str(\\\u201cDrowner Brain, \\\u201c);\n    recipe.push('W'); // Adding a single character, notice the single quotes\n\n    // Removing the last ingredient (mistakenly added)\n    recipe.pop();\n\n    // Combining with another potion recipe\n    let enhanced_recipe = format!(\\\u201c{} and Thunderbolt\\\u201c, recipe.trim());\n\n    // Print the final potion recipe\n    println!(\\\u201cUpdated Potion Recipe: {}\\\u201c, enhanced_recipe);\n}\n```\n\nGeralt uses `push_str`, `push`, and `pop` to craft and update his potion recipe. The `format!` macro then combines two recipes into one, like mixing ingredients to enhance a potion's effect.",
        "task": "Inspired by Geralt's recipe updating methods, try manipulating a `String` in your own Rust program. Add, modify, and remove elements to create a final version of a text. Use the `push_str`, `push`, and `pop` methods, and then combine different pieces using `format!`. Show the changes step by step and explain each modification.\n\n```rust\nfn main() {\n  // TODO: Initialize and update a String, then combine it with another using format!\n}\n```\n\n**Plan:**\n1. Initialize a mutable `String` and begin with a basic sentence or phrase.\n2. Use `push_str` and `push` to add more text or characters.\n3. Use `pop` to remove the last character or mistaken addition.\n4. Combine your updated string with another text using `format!`.\n5. Print out the final combined text to show how it has evolved. Start by initializing your `String`."
      },
      {
        "heading": "Iterating Over Strings",
        "content": "Iterating over strings in Rust can be compared to Geralt exploring different regions of the Continent.\n\nImagine Geralt coming across a mysterious inscription. He needs to analyze it character by character. This is how we might approach it in Rust using a couple of handy methods:\n\n```rust\nfn main() {\n  let inscription = \\\u201cKaer Morhen: Witcher School\\\u201c;\n\n  // Splitting the inscription into words\n  for word in inscription.split_whitespace() {\n    println!(\\\u201cWord: {}\\\u201c, word);\n  }\n\n  // Splitting based on a specific character\n  for part in inscription.split(':') {\n    println!(\\\u201cPart: {}\\\u201c, part.trim());\n  }\n\n  // Iterating over each character\n  for ch in inscription.chars() {\n    println!(\\\u201cCharacter: {}\\\u201c, ch);\n  }\n}\n```\n\nHere, `split_whitespace`, `split`, and `chars` methods help Geralt break down the inscription into understandable parts. These methods work on both types of strings (`String` and `&str`).",
        "task": "Following Geralt's example, write your own Rust code to iterate over a string in different ways. Split the string into words, divide it based on a character of your choice, and then iterate over each character. Use this exercise to familiarize yourself with string manipulation and iteration in Rust.\n\n```rust\nfn main() {\n  // TODO: Create a string and iterate over it in different ways\n}\n```\n\n**Plan:**\n1. Create a `String` or `&str` containing a sentence or phrase.\n2. Use `split_whitespace` to iterate over and print each word.\n3. Use `split` with a specific character to break the string into parts and print each one.\n4. Use `chars` to iterate over and print each character in the string. Begin by creating your string and splitting it into words."
      },
      {
        "heading": "Converting Between Strings and Other Types",
        "content": "Just as Geralt converts resources found in the Continent into useful items and potions, Rust allows for the conversion between strings and other types.\n\nFor instance, Geralt might find an ancient scroll with numbers that need to be used as text or vice versa.\n\n```rust\nfn main() {\n    let numerical_string = String::from(\\\u201c2024\\\u201c);\n\n    // Converting string to i32\n    let year: i32 = numerical_string.parse().expect(\\\u201cNot a number!\\\u201c);\n    println!(\\\u201cThe year in the scroll: {}\\\u201c, year);\n\n    // Converting a number back to string\n    let new_string = year.to_string();\n    println!(\\\u201cThe year as a string: {}\\\u201c, new_string);\n\n    // Converting a boolean to a string\n    let is_witcher = true;\n    let status = is_witcher.to_string();\n    println!(\\\u201cIs Geralt a Witcher? {}\\\u201c, status);\n}\n```\n\nRust can convert different data types with the helpful `parse` method and still keep flexible error handling.",
        "task": "Based on the examples, create your own Rust program that converts between strings and other types. Include at least one conversion from a string to a numerical type, and then back to a string. Also, try converting another data type (like a boolean or float) to a string. Illustrate each conversion step with println! statements.\n\n```rust\nfn main() {\n  // TODO: Create variables and demonstrate type conversions\n}\n```\n\n**Plan:**\n1. Start with a string that represents a numerical value. Convert it to the respective numerical type and handle possible errors.\n2. Convert the numerical value back to a string.\n3. Choose another data type and convert it to a string.\n4. Use println! statements to show the results of each conversion. Begin by creating a string that represents a numerical value."
      },
      {
        "heading": "Advanced String Manipulation",
        "content": "Advanced string manipulation in Rust can be compared to Geralt's use of signs, tactics, and strategies in combat.\n\nSuppose Geralt is crafting a coded message that needs to be encrypted or formatted in a specific way.\n\n```rust\nfn main() {\n    let secret_message = String::from(\\\u201cWitcher of Rivia\\\u201c);\n\n    // Reversing a string to encode a secret message\n    let reversed_message: String = secret_message.chars().rev().collect();\n    println!(\\\u201cReversed Message: {}\\\u201c, reversed_message);\n\n    // Capitalizing each word for a code\n    let mut capitalized_words = secret_message\n        .split_whitespace()\n        .map(|word| {\n            let mut chars = word.chars();\n            match chars.next() {\n                None => String::new(),\n                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),\n            }\n        })\n        .collect::<Vec<String>>()\n        .join(\\\u201c \\\u201c);\n    println!(\\\u201cCapitalized Message: {}\\\u201c, capitalized_words);\n\n    // Inserting a character at a specific index\n    capitalized_words.insert(7, ':'); // Splitting 'Witcher' and 'of'\n    println!(\\\u201cModified Message: {}\\\u201c, capitalized_words);\n}\n```\n\nIn this last example, you can get a small taste of the depth of string handling in Rust using iterators and closures. We manipulate the `secret_message` through reversing, capitalizing, and tampering.",
        "task": "Following the steps from the example, experiment with advanced string manipulation in your own Rust program. Create a string and then apply a series of manipulations: reverse it, capitalize each word, and insert a character at a specific index. Use iterators, methods, and collections to achieve these goals. Explain each manipulation with comments and print out the results to show the changes.\n\n```rust\nfn main() {\n  // TODO: Create a string and apply advanced manipulations\n}\n```\n\n**Plan:**\n1. Initialize a string to manipulate.\n2. Reverse the string and print out the result.\n3. Capitalize each word in the original string and print the result.\n4. Insert a character at a specified index in the capitalized string and print the final message. Start with creating and reversing a string."
      }
            
    ]
  },
  {
    "order": 5,
    "title": "Vectors",
    "subtitle": "With examples from The Lord of the Rings",
    "url": "https://medium.com/rustaceans/rust-vectors-a-fun-guide-with-examples-ba9402139e5a?sk=a928927b3dd3108a4c9e4b7e8a5a6936",
    "snippets": [
      {
        "heading": "The Basics of Vectors",
        "content": "Simply speaking, a vector is a dynamic array that we can resize at will.\n\nImagine Frodo preparing his backpack for the journey. He needs to store various items in his backpack. If he knew from the beginning how many items will be put in, the backpack could be represented by an array. But since Frodo actually doesn't know how many items he will pack along the way, it's better to have it represented as a vector.\n\nfn main() {\n  // Creating an empty Vector\n  let mut frodos_backpack = Vec::new();\n\n  // Adding an unknown number of items to the Vector\n  frodos_backpack.push(\u201cLembas Bread\u201c);\n  frodos_backpack.push(\u201cElven Cloak\u201c);\n  frodos_backpack.push(\u201cSting - the sword\u201c);\n\n  println!(\u201cFrodo's Vector-Backpack: {:?}\u201c, frodos_backpack);\n\n  // Creating a Vector using a macro\n  let frodos_backpack_2 = vec![\u201cLembas Bread\u201c, \u201cElven Cloak\u201c, \u201cSting - the sword\u201c];\n\n  println!(\u201cFrodo's Vector-Backpack: {:?}\u201c, frodos_backpack_2);\n}\n\nThere are two ways of creating a vector.\n- `Vec::new()` creates a new, empty Vector. The `push` method adds items to Frodo's backpack, just as he would gather supplies for his journey.\n- `vec!` macro enables us to initialize a vector in just one line.",
        "task": "Your task is to recreate the vector creation and item addition in Rust. Follow these steps:\n1. Declare a mutable vector named `frodos_backpack` using `Vec::new()`.\n2. Add three items to the vector: 'Lembas Bread', 'Elven Cloak', and 'Sting - the sword'.\n3. Print the vector to the console.\nHere is the code snippet to start with:\n\nfn main() {\n  /* TODO: let mut frodos_backpack = Vec::new();\n\n  frodos_backpack.push(\u201cLembas Bread\u201c);\n  frodos_backpack.push(\u201cElven Cloak\u201c);\n  frodos_backpack.push(\u201cSting - the sword\u201c); */\n\n  println!(\u201cFrodo's Vector-Backpack: {:?}\u201c, frodos_backpack);\n}\n\nStart by declaring the mutable vector `frodos_backpack` and then follow the remaining steps."
      },
      {
        "heading": "Accessing Elements",
        "content": "Just as members of the Fellowship have different roles, elements in a Vector can be accessed and utilized differently.\n\nFrodo needs to consult different members of the Fellowship for advice.\n\n```rust\nfn main() {\n  let fellowship = vec![\\\u201cGandalf\\\u201c, \\\u201cAragorn\\\u201c, \\\u201cLegolas\\\u201c, \\\u201cGimli\\\u201c];\n\n  // Accessing elements using indexing\n  let wizard = fellowship[3];\n  println!(\\\u201cThe wizard in the Fellowship is: {}\\\u201c, wizard);\n\n  // Accessing elements using get method for safety\n  match fellowship.get(3) {\n    Some(member) => println!(\\\u201cThe fifth member is: {}\\\u201c, member),\n    None => println!(\\\u201cThere is no fifth member.\\\u201c),\n  }\n}\n```\n\nBy using `fellowship[3]`, Frodo can access the first element directly. But what if a member with such an index doesn't exist? We would get an error.\n\nOn the other hand, the `get` method provides a safer way to access elements because it returns `None` if the index is out of bounds, like seeking a member not present in the Fellowship.",
        "task": "Alter the given Rust code to illustrate a different scenario where you need to access elements from a different vector. Apply both direct indexing and the `get` method for comparison, and handle the potential outcomes in each case.\n\n```rust\nfn main() {\n  let new_vector = vec![/* TODO: Fill this with different elements */];\n\n  // Accessing elements using indexing\n  /* TODO: Access an element directly and print it */\n\n  // Accessing elements using get method for safety\n  /* TODO: Use get to access an element and match to handle the result */\n}\n```\n\n**Plan:**\n1. Create a new vector with unique elements.\n2. Directly index into this vector to retrieve an element and handle errors if the index is out of range.\n3. Use the `get` method to safely attempt to access an element, and use a `match` statement to handle the possible `Some` or `None` outcomes. Begin by creating and filling your new vector."
      },
      {
        "heading": "Iterating Over Vectors",
        "content": "We can iterate over vectors so that we get access to each element.\n\nLet's imagine that the Ents decide to march against Saruman and each of them wants to announce it.\n\n```rust\nfn main() {\n  let ents = vec![\\\u201cTreebeard\\\u201c, \\\u201cQuickbeam\\\u201c, \\\u201cBeechbone\\\u201c];\n\n  // Iterating over the Ents\n  for ent in ents.iter() {\n    println!(\\\u201cI, {}, am marching to Isengard!\\\u201c, ent);\n  }\n}\n```\n\nIn this code, `ents.iter()` creates an iterator over the Vector, allowing each Ent to take action, such as announcing their march.",
        "task": "Using the code example as a guide, create a new scenario in which you iterate over a vector containing different elements. Design this new scenario so that each element in the vector has a specific role or action when iterated over.\n\n```rust\nfn main() {\n  let new_vector = vec![/* TODO: Insert your elements here */];\n\n  // Iterating over new elements\n  /* TODO: Iterate over your vector and apply an action for each element */\n}\n```\n\n**Plan:**\n1. Define a new vector with distinct elements.\n2. Write a for loop to iterate over this vector, using `.iter()`.\n3. For each element in the iteration, execute an action that prints out a message or performs some operation. Begin by defining your new vector."
      },
      {
        "heading": "Modifying Elements",
        "content": "Just as characters in Middle-Earth grow and change, elements in a Vector can be modified.\n\nThe sword Narsil is reforged into Andril, symbolizing transformation. Similarly, elements in a Vector can be transformed.\n\n```rust\nfn main() {\n  let mut weapons = vec![\\\u201cNarsil\\\u201c, \\\u201cGlamdring\\\u201c, \\\u201cSting\\\u201c];\n\n  // Reforging Narsil into Andril\n  weapons[0] = \\\u201cAndril\\\u201c;\n\n  println!(\\\u201cThe reforged weapons: {:?}\\\u201c, weapons);\n}\n```\n\nHere, modifying the first element of the `weapons` Vector symbolizes the reforging of Narsil into Andril. Notice that the Vector was initialized as mutable by using `let mut`.",
        "task": "Replicate the concept of transformation shown in the example in a new scenario. Create a mutable vector and modify one of its elements to reflect a change or evolution. Explain the significance of the change in your scenario.\n\n```rust\nfn main() {\n  let mut new_vector = vec![/* TODO: Insert initial elements */];\n\n  /* TODO: Modify an element of the vector to signify a change */\n\n  println!(\\\u201cAfter the change: {:?}\\\u201c, new_vector);\n}\n```\n\n**Plan:**\n1. Initialize a mutable vector with distinct elements.\n2. Change one of the elements to reflect some form of evolution or transformation.\n3. Print out the modified vector and discuss the significance of the change you made. Begin by creating and initializing your mutable vector."
      },
      {
        "heading": "Using Enumerations with Vectors",
        "content": "In Middle-Earth, beings of different races unite for a common cause. Similarly, Rust's enumerations (the `enum` type) allow Vectors to store elements of different types.\n\nA council meeting is held with representatives of different races.\n\n```rust\nenum MiddleEarthBeing {\n  Human(String),\n  Elf(String),\n  Dwarf(String),\n  Hobbit(String),\n}\n\nfn main() {\n  let council_members = vec![\n    MiddleEarthBeing::Human(\\\u201cAragorn\\\u201c.to_string()),\n    MiddleEarthBeing::Elf(\\\u201cLegolas\\\u201c.to_string()),\n    MiddleEarthBeing::Dwarf(\\\u201cGimli\\\u201c.to_string()),\n    MiddleEarthBeing::Hobbit(\\\u201cFrodo\\\u201c.to_string()),\n  ];\n\n  // Discussing the plan to defeat Sauron\n  for member in council_members {\n    match member {\n      MiddleEarthBeing::Human(name) => {\n        println!(\\\u201c{} says we should use strategy.\\\u201c, name)\n      }\n      MiddleEarthBeing::Elf(name) => {\n        println!(\\\u201c{} suggests an alliance with the Elves.\\\u201c, name)\n      }\n      MiddleEarthBeing::Dwarf(name) => {\n        println!(\\\u201c{} recommends gathering weapons.\\\u201c, name)\n      }\n      MiddleEarthBeing::Hobbit(name) => {\n        println!(\\\u201c{} offers to take the Ring.\\\u201c, name)\n      }\n    }\n  }\n}\n```\n\nThis snippet demonstrates how enums combined with Vectors can represent a diverse group, each with its unique characteristics and contributions.",
        "task": "Utilize the structure provided to create your own scenario using enums with a vector. Illustrate different entities or elements that come together for a purpose, similar to the council meeting. Each element should have its own behavior or contribution when iterated over.\n\n```rust\nenum YourEnum {\n  /* TODO: Define different variants for your scenario */\n}\n\nfn main() {\n  let your_vector = vec![\n    /* TODO: Populate your vector with different enum instances */\n  ];\n\n  /* TODO: Iterate over your vector and match each element to execute its unique action */\n}\n```\n\n**Plan:**\n1. Define an enum with different variants that fit your new scenario.\n2. Populate a vector with instances of these enum variants.\n3. Iterate over the vector and use a match statement to execute a unique action for each variant. Begin by defining your enum and its variants."
      },
      {
        "heading": "Vector Capacity and Reallocation",
        "content": "The journey through Middle-Earth is unpredictable, requiring flexibility in plans and resources. Similarly, a Vector in Rust has a capacity that can change dynamically.\n\nAs the Fellowship prepares for its journey, the members must ensure they have enough supplies, much like managing the capacity of a Vector.\n\n```rust\nfn main() {\n  let mut supplies = Vec::with_capacity(5);\n\n  supplies.push(\\\u201cLembas Bread\\\u201c);\n  supplies.push(\\\u201cElven Rope\\\u201c);\n  // ... more items are added\n\n  println!(\\\u201cTotal supplies: {}\\\u201c, supplies.len());\n  println!(\\\u201cCapacity of the backpack: {}\\\u201c, supplies.capacity());\n}\n```\n\nIn this example, `Vec::with_capacity(5)` creates a Vector with an initial capacity for 5 items, ensuring the Fellowship has a pre-determined space for essential supplies. As items are added, Rust automatically increases the capacity if needed, just as the Fellowship might acquire more supplies along their journey.",
        "task": "Following the provided example, write a new Rust program that demonstrates managing the capacity of a vector in a different context. Explain how items are added and how the capacity changes dynamically. Show this by adding items to the vector and then displaying its length and capacity.\n\n```rust\nfn main() {\n  let mut new_vector = Vec::with_capacity(/* TODO: Decide on an initial capacity */);\n\n  /* TODO: Add items to the vector */\n\n  println!(\\\u201cCurrent items count: {}\\\u201c, new_vector.len());\n  println!(\\\u201cCurrent capacity: {}\\\u201c, new_vector.capacity());\n}\n```\n\n**Plan:**\n1. Initialize a new vector with a specific initial capacity.\n2. Add various items to the vector, demonstrating how it can grow beyond its initial capacity if necessary.\n3. Print out the vector's current length and capacity to showcase the dynamic reallocation. Start by deciding on the initial capacity for your vector."
      },
      {
        "heading": "Slicing Vectors",
        "content": "Like choosing the right path in the Mines of Moria, slicing a Vector in Rust involves selecting a specific portion for focused operations.\n\nThe Fellowship decides to divide their responsibilities.\n\n```rust\nfn main() {\n  let fellowship = vec![\\\u201cFrodo\\\u201c, \\\u201cSam\\\u201c, \\\u201cGandalf\\\u201c, \\\u201cAragorn\\\u201c, \\\u201cLegolas\\\u201c, \\\u201cGimli\\\u201c, \\\u201cBoromir\\\u201c];\n\n  // Creating a slice for the Hobbits\n  let hobbits = &fellowship[0..2]; // Frodo and Sam\n\n  println!(\\\u201cHobbits in the Fellowship: {:?}\\\u201c, hobbits);\n}\n```\n\nHere, slicing the `fellowship` Vector allows for focusing on just the Hobbits, leaving the others behind.",
        "task": "Following the example, write a new Rust program that demonstrates slicing a vector in a different scenario. Create a vector and then use slicing to isolate a specific section of it. Explain the significance of the chosen slice in your context.\n\n```rust\nfn main() {\n  let new_vector = vec![/* TODO: Fill this with relevant elements */];\n\n  /* TODO: Create a slice from the vector */\n\n  println!(\\\u201cSelected portion: {:?}\\\u201c, /* TODO: Insert your slice variable here */);\n}\n```\n\n**Plan:**\n1. Create a new vector filled with relevant elements for your scenario.\n2. Utilize slicing to extract a specific portion of this vector.\n3. Print out and discuss the significance of the selected slice. Begin by populating your vector with suitable elements."
      },
      {
        "heading": "Removing Elements",
        "content": "In Middle-Earth, certain allies and enemies may leave the journey, just as elements can be removed from a Vector in Rust.\n\nConsider a scenario where the Fellowship must part ways with one of its members.\n\n```rust\nfn main() {\n    let mut fellowship = vec![\\\u201cFrodo\\\u201c, \\\u201cSam\\\u201c, \\\u201cGandalf\\\u201c, \\\u201cAragorn\\\u201c, \\\u201cLegolas\\\u201c, \\\u201cGimli\\\u201c, \\\u201cBoromir\\\u201c];\n\n    // Boromir's departure\n    let departed = fellowship.pop(); // Removes the last element\n\n    println!(\\\u201cDeparted member: {:?}\\\u201c, departed);\n    println!(\\\u201cRemaining Fellowship: {:?}\\\u201c, fellowship);\n}\n```\n\nThe `pop` method removes the last element of the Vector. It returns an `Option`, which is `Some(value)` if an element was removed, or `None` if the Vector was empty, reflecting the uncertainty of partings in Middle-Earth.",
        "task": "Following the pattern in the example, write a new Rust program that involves removing elements from a vector in a different context. Describe a scenario where removing an element is significant, and show how you handle the removed element.\n\n```rust\nfn main() {\n    let mut new_vector = vec![/* TODO: Fill with elements */];\n\n    /* TODO: Remove an element and handle the outcome */\n\n    println!(\\\u201cRemoved element: {:?}\\\u201c, /* TODO: Output the removed element */);\n    println!(\\\u201cUpdated list: {:?}\\\u201c, new_vector);\n}\n```\n\n**Plan:**\n1. Create and populate a mutable vector relevant to your new scenario.\n2. Remove an element from the vector, capturing the outcome.\n3. Print out the removed element and the updated vector. Begin by creating your vector and deciding which element to remove."
      },
      {
        "heading": "Concatenating Vectors",
        "content": "In the saga of Middle-Earth, different groups often come together to form a larger force, much like how Vectors can be concatenated in Rust to form a larger collection.\n\nImagine various groups in Middle-Earth uniting for a significant battle.\n\n```rust\nfn main() {\n    let elves = vec![\\\u201cLegolas\\\u201c, \\\u201cThranduil\\\u201c];\n    let dwarves = vec![\\\u201cGimli\\\u201c, \\\u201cThorin\\\u201c];\n\n    // Uniting Elves and Dwarves\n    let united_army = [elves, dwarves].concat();\n\n    println!(\\\u201cUnited army: {:?}\\\u201c, united_army);\n}\n```\n\nThe `concat` method merges multiple Vectors into one. The `united_army` Vector combines the elements of the `elves` and `dwarves` Vectors. This method is pretty useful when you need to join elements from different sources into a new Vector.",
        "task": "Based on the example, create a new Rust program demonstrating the concatenation of vectors in a different context. Show how multiple vectors can be combined into one larger vector and describe the significance of this action in your scenario.\n\n```rust\nfn main() {\n    let vector_one = vec![/* TODO: Fill with elements */];\n    let vector_two = vec![/* TODO: Fill with elements */];\n\n    /* TODO: Concatenate the vectors and store the result */\n\n    println!(\\\u201cCombined vector: {:?}\\\u201c, /* TODO: Output the combined vector */);\n}\n```\n\n**Plan:**\n1. Define and populate at least two vectors with relevant elements.\n2. Use the `concat` method to combine these vectors into one.\n3. Discuss the significance of the combined vector in the context of your scenario. Begin by creating and filling your vectors."
      },
      {
        "heading": "Extending Vectors",
        "content": "As alliances are formed in Middle-Earth, bringing together different factions for a common purpose, Rust allows the combination of Vectors using the `extend` method. It sounds similar to `concat`, but the difference is that we append all elements of one Vector to another, enhancing the first Vector without creating a new one.\n\nImagine the armies of Elves and Dwarves joining the forces of Aragorn to stand united against the forces of darkness.\n\n```rust\nfn main() {\n    let mut army_of_men = vec![\\\u201cAragorn\\\u201c];\n    let elves_and_dwarves = vec![\\\u201cLegolas\\\u201c, \\\u201cGimli\\\u201c];\n\n    // The Elves and Dwarves join the coalition\n    army_of_men.extend(elves_and_dwarves);\n\n    println!(\\\u201cUnited Army: {:?}\\\u201c, army_of_men);\n}\n```\n\nThe `extend` method adds the elements of `elves_and_dwarves` into `army_of_men`.",
        "task": "Based on the example, write a new Rust program demonstrating how one vector can be extended by another. Provide a new context for this action, and explain the significance of the resulting vector in that scenario.\n\n```rust\nfn main() {\n    let mut primary_vector = vec![/* TODO: Initialize with some elements */];\n    let additional_elements = vec![/* TODO: Initialize with other elements */];\n\n    /* TODO: Extend the primary vector with the additional elements */\n\n    println!(\\\u201cExpanded collection: {:?}\\\u201c, primary_vector);\n}\n```\n\n**Plan:**\n1. Initialize a mutable vector and another vector with different elements.\n2. Use the `extend` method to add the second vectors elements into the first one.\n3. Print out the updated first vector and discuss how this extension impacts the overall scenario. Start by initializing your primary vector."
      },
      {
        "heading": "Clearing Vectors",
        "content": "Just as the One Ring was ultimately destroyed in Mount Doom, clearing all traces of its power, a Vector in Rust can be completely cleared of its elements.\n\nImagine a scenario where, after the final battle, the heroes discard their weapons to celebrate the end of the war.\n\n```rust\nfn main() {\n    let mut weapons = vec![\\\u201cAndril\\\u201c, \\\u201cSting\\\u201c, \\\u201cGlamdring\\\u201c];\n\n    // Discarding all weapons\n    weapons.clear();\n\n    println!(\\\u201cWeapons after the war: {:?}\\\u201c, weapons);\n}\n```\n\nThe `clear` method removes all elements from the `weapons` Vector, leaving it empty. This action reflects the notion of putting aside arms and tools of war, as Middle-Earth enters a period of peace. The `clear` method is useful for resetting a Vector for reuse, without reallocating new memory.",
        "task": "Following the example provided, write a new Rust program that demonstrates the clearing of a vector in a different context. Create a vector filled with elements and then clear it, explaining the significance of this action within your scenario.\n\n```rust\nfn main() {\n    let mut your_vector = vec![/* TODO: Fill with relevant elements */];\n\n    /* TODO: Clear the vector */\n\n    println!(\\\u201cState after clearing: {:?}\\\u201c, your_vector);\n}\n```\n\n**Plan:**\n1. Initialize a mutable vector with a variety of elements that fit your new scenario.\n2. Use the `clear` method to remove all elements from the vector.\n3. Explain the narrative or practical reasons behind clearing this particular vector in your context. Begin by creating and filling your vector."
      }
    ]
  },
  {
    "order": 6,
    "title": "Functions",
    "subtitle": "With examples from Star Wars",
    "url": "https://medium.com/rustaceans/rust-functions-a-fun-guide-with-examples-e9b43833a39b?sk=93bcd3e3cfca4bf54ab54cbbe7137cd0",
    "snippets": [
      {
        "heading": "How to Create a Function",
        "content": "In Rust, functions are like the starships in Star Wars --- essential tools to navigate the vastness of coding space.\n\nConsider a scenario where you're preparing a starship for launch.\n\n```rust\n// Defining a function to launch a starship\nfn launch_starship() {\n  println!(\\\u201cStarship launched!\\\u201c);\n}\n\nfn main() {\n  // Calling the launch_starship function\n  launch_starship();\n}\n```\n\nYou can see the `launch_starship` function that focuses on a specific task. That function is called inside of another function called `main`.\n\nThe `main` function is like a wrapper to everything --- as space is a wrapper to all spaceships. It's the entry point of every program you make in Rust.",
        "task": "Using the example above as a guide, create your own Rust function for a different specific task, and call this function from `main`. Provide a brief context for the function and explain its role within the program.\n\n```rust\n// Defining a new function for a specific task\nfn your_new_function() {\n  // Implement your function logic here\n}\n\nfn main() {\n  // Calling your new function\n  your_new_function();\n}\n```\n\n**Plan:**\n1. Define a new Rust function that performs a distinct task relevant to your chosen scenario.\n2. Implement the logic within your new function.\n3. Call this new function from the `main` function to demonstrate its usage. Start by deciding on the task your new function will perform."
      },
      {
        "heading": "Parameters and Arguments",
        "content": "Starships can be customized for different missions. Similarly, functions in Rust can take parameters to perform varied tasks.\n\nLet's load specific cargo into the Millennium Falcon using a function with parameters.\n\n```rust\n// Function with parameters to load cargo\nfn load_cargo(cargo: &str, quantity: u32) {\n  println!(\\\u201cLoading {} units of {}\\\u201c, quantity, cargo);\n}\n\nfn main() {\n  // Calling the function with arguments\n  load_cargo(\\\u201cCoaxium\\\u201c, 100);\n}\n```\n\nHere, `cargo` of type `&str` and `quantity` of type `u32` are parameters that allow the `load_cargo` function to be versatile and reusable for different types of cargo.\n\nThe specific values we use as parameters such as `\u201cCoaxium\u201c` and `100` are called arguments.",
        "task": "Based on the example provided, write a new Rust function that takes parameters and is called from `main` with specific arguments. Create a scenario where this function would be necessary and explain how the parameters enhance its flexibility.\n\n```rust\n// Defining a function with parameters for a specific scenario\nfn your_function(/* TODO: Define your parameters */) {\n  // Implement the function logic here\n}\n\nfn main() {\n  // Calling your function with specific arguments\n  your_function(/* TODO: Provide arguments */);\n}\n```\n\n**Plan:**\n1. Define a new function with appropriate parameters for your scenario.\n2. Implement the function to perform a specific task using these parameters.\n3. Call this function from `main`, supplying arguments that demonstrate the functions utility. Start by defining the parameters for your new function."
      },
      {
        "heading": "Return Values",
        "content": "Just as starships return with valuable data or cargo, functions in Rust can return values after execution.\n\nImagine sending a reconnaissance mission to find a new base for the Rebel Alliance.\n\n```rust\n// Function returning the location of a new base\nfn scout_for_base() -> String {\n  \\\u201cYavin IV\\\u201c.to_string()\n}\n\nfn main() {\n  // Function returning a value\n  let base_location = scout_for_base();\n  println!(\\\u201cNew Rebel base located at: {}\\\u201c, base_location);\n}\n```\n\nThe function `scout_for_base` returns a `String` containing the location of a new base, similar to a successful scouting mission in \u201cStar Wars.\u201c",
        "task": "Following the example provided, write a new Rust program with a function that returns a specific value. Use this function within the `main` function and handle the returned value appropriately. Create a context for the function, explaining how the return value is significant in that scenario.\n\n```rust\n// Defining a function that returns a specific value\nfn your_function() -> /* TODO: Define the return type */ {\n  // Implement the function to return a specific value\n}\n\nfn main() {\n  // Retrieving the return value from your function\n  let returned_value = your_function();\n  println!(\\\u201cReceived value: {}\\\u201c, returned_value);\n}\n```\n\n**Plan:**\n1. Define a new function that performs a specific task and returns a value.\n2. Implement this function to return a relevant value for your scenario.\n3. Use this function within `main`, and display the returned value. Begin by deciding what task your function will perform and what type of value it will return."
      },
      {
        "heading": "Function Signatures",
        "content": "Function signatures in Rust are like the mission briefings in Star Wars. They outline what a function will do and what it needs, but we wouldn't care about the internals of the function.\n\nIf we want to plan a mission to Endor, we need to define what types of resources are needed (parameters of the function) and what the mission will accomplish (return values of the function).\n\n```rust\nfn plan_mission_to_endor(troops: u32, starships: u32) -> String {\n  format!(\\\u201cSending {} troops and {} starships to Endor.\\\u201c, troops, starships)\n}\n\nfn main() {\n  let mission_plan = plan_mission_to_endor(1000, 5);\n  println!(\\\u201c{}\\\u201c, mission_plan);\n}\n```\n\nA function signature is the name of the function, its parameters, and return values. In our case, the function signature is:\n`fn plan_mission_to_endor(troops: u32, starships: u32) -> String`",
        "task": "Using the example above as inspiration, create your own Rust function with a clear signature, specifying the parameters and return type. Then call this function from `main`. Provide a different context for your function, explaining its purpose and how it uses its parameters and return value.\n\n```rust\n// Define a function with a clear signature for a specific task\nfn your_function(/* TODO: Specify parameters */) -> /* TODO: Specify return type */ {\n  // Implement the function logic here\n}\n\nfn main() {\n  // Call your function and use the return value\n  let result = your_function(/* TODO: Provide arguments */);\n  println!(\\\u201cResult of the function: {}\\\u201c, result);\n}\n```\n\n**Plan:**\n1. Define a new function with parameters and a return type suitable for your chosen scenario.\n2. Implement the function to perform its task using these parameters and produce a return value.\n3. Call this function from `main` and display the result. Begin by deciding the purpose of your function and its signature."
      },
      {
        "heading": "Functions of Objects",
        "content": "Functions of objects are called methods or associated functions. They can be likened to the specialized functions of droids in Star Wars. Each droid (object) has unique capabilities (functions).\n\nLet's use R2-D2's methods to hack into the Death Star's mainframe.\n\n```rust\nstruct  Droid {\n  name: String,\n}\n\nimpl  Droid {\n  // Associated function to create a new Droid\n  fn  new(name: &str) -> Droid {\n    Droid {\n      name: name.to_string(),\n    }\n  }\n\n  // Method for a Droid to hack systems\n  fn hack_system(&self) {\n    println!(\\\u201c{} is hacking into the system...\\\u201c, self.name);\n  }\n}\n\nfn main() {\n  // Create a new Droid using the associated function\n  let bb8 = Droid::new(\\\u201cBB-8\\\u201c);\n\n  // Let the droid use a method\n  bb8.hack_system();\n}\n```\n\nSo what's the difference between an associated function and a method? Notice the `&self` part (or sometimes `&mut self`). I am simplifying a little here, but a method has access to the struct itself and can either read it or modify it. An associated function cannot.",
        "task": "Based on the example, create a new struct and implement methods and associated functions for it. Reflect on a unique scenario where your struct (akin to a droid) would perform specific tasks through these methods and functions.\n\n```rust\n// Define your struct\nstruct YourStruct {\n  // Define fields\n}\n\nimpl YourStruct {\n  // Define an associated function\n  fn new(/* Parameters */) -> YourStruct {\n    // Implementation\n  }\n\n  // Define a method\n  fn your_method(&self) {\n    // Implementation\n  }\n}\n\nfn main() {\n  // Create an instance of your struct using the associated function\n  let your_instance = YourStruct::new(/* Arguments */);\n\n  // Call a method on your instance\n  your_instance.your_method();\n}\n```\n\n**Plan:**\n1. Design and implement a new struct with at least one field.\n2. Create an associated function that constructs instances of your struct.\n3. Implement a method that performs an action or returns information about the instance. Begin by defining your struct and its fields."
      },
      {
        "heading": "Error Handling",
        "content": "Handling errors in functions is like piloting a starship through an asteroid field. You should be prepared for and respond to unexpected situations.\n\nImagine piloting the Millennium Falcon while evading TIE fighters, using error handling to navigate challenges.\n\n```rust\nfn navigate_asteroid_field(speed: u32) -> Result<(), String> {\n  if speed < 20 {\n    Err(\\\u201cSpeed too slow! Risk of asteroid collision.\\\u201c.to_string())\n  } else {\n    Ok(())\n  }\n}\n\nfn main() {\n  match navigate_asteroid_field(15) {\n    Ok(()) => println!(\\\u201cSafe passage through the asteroid field.\\\u201c),\n    Err(e) => println!(\\\u201cError: {}\\\u201c, e),\n  }\n}\n```\n\nThe function `navigate_asteroid_field` returns a `Result` type, indicating either successful navigation (`Ok`) or an error (`Err`). This is similar to responding to the ever-changing conditions of space travel.",
        "task": "Based on the example provided, write a new Rust program that utilizes the `Result` type for error handling within a different context. Design a function that could result in success or failure based on the parameters it's given, and handle both outcomes in `main`. Describe a real-world scenario where this error handling would be analogous.\n\n```rust\n// Define a function with potential for success or failure\nfn your_function(/* Parameters */) -> Result<(), String> {\n  // Implement the function logic\n}\n\nfn main() {\n  match your_function(/* Arguments */) {\n    Ok(()) => println!(\\\u201cSuccess message\\\u201c),\n    Err(e) => println!(\\\u201cError: {}\\\u201c, e),\n  }\n}\n```\n\n**Plan:**\n1. Create a function that performs a specific task, returning a `Result` type to signify success (`Ok`) or failure (`Err`).\n2. Implement logic within this function that determines whether it succeeds or fails.\n3. In `main`, call your function and use pattern matching to handle the different outcomes. Start by defining the parameters for your function."
      },
      {
        "heading": "Closures",
        "content": "Closures in Rust are like using the Force in Star Wars.\n\nIf a Jedi was using the Force to move objects, it would be similar to how closures capture variables from their surroundings.\n\n```rust\nfn main() {\n  let force_strength = 10;\n\n  // The force is a special type of function called closure\n  let use_force = |mass: u32| mass < force_strength;\n\n  let spaceship_mass = 5;\n  if use_force(spaceship_mass) {\n    println!(\\\u201cUsing the Force to move the object.\\\u201c);\n  } else {\n    println!(\\\u201cObject is too heavy for the Force.\\\u201c);\n  }\n}\n```\n\nNotice that we don't pass the value of the `force_strength` variable as an argument to the closure. It's just captured from the environment. On the other hand, the closure receives the `mass` value from the parameter.\n\nA closure can capture its environment in three ways: taking ownership, borrowing mutably, or borrowing immutably. It depends on how the closure is used in the code. The default is to borrow immutably, which is what happens in the example with `force_strength`. Rust infers that `force_strength` does not need to be modified by the closure, so it allows the closure to access it through an immutable borrow.\n\nThe choice of whether to use capturing variables from the environment or passing them as parameters is about the balance between readability, performance, and the Rust ownership rules. For example, capturing might be the right choice if a closure is only used in a narrow scope and closely tied to that scope's variables. On the other hand, if the closure is part of a public API or designed to be reused in different contexts, making it accept arguments might be more appropriate.",
        "task": "Inspired by the example, write your own Rust program using a closure in a new context. This closure should capture an environmental variable and use it within its logic. Reflect on why using a closure is appropriate for your scenario, considering factors like scope and reusability.\n\n```rust\nfn main() {\n  let environmental_variable = /* Initialize your variable */;\n\n  // Define your closure here\n  let your_closure = /* Closure that uses environmental_variable */;\n\n  /* Use the closure with a suitable argument */\n}\n```\n\n**Plan:**\n1. Define an environmental variable relevant to your new scenario.\n2. Create a closure that captures this variable and uses it to perform some logic.\n3. Utilize this closure within your main function, applying it to a suitable situation or value. Begin by initializing your environmental variable."
      }
    ]
  },
  {
    "order": 7,
    "title": "XXXXX",
    "subtitle": "With examples from XXXXX",
    "url": "XXXXX",
    "snippets": []
  }
]