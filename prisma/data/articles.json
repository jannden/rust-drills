[
  {
    "order": 1,
    "title": "Enums",
    "subtitle": "With examples from The Matrix",
    "url": "https://medium.com/rustaceans/rust-enums-a-fun-guide-with-examples-f3bb0f590d93?sk=08825ba512c2cf2638c1fa3e177a643a",
    "snippets": [
      {
        "order": 1,
        "heading": "The Basics of Enums",
        "content": "An Enum is a type that can be any one of several variants. It\u2019s similar to how Neo must understand his identity: is he Thomas Anderson, a regular software engineer, or Neo, the chosen one?\n\nImagine a scenario where Morpheus offers Neo a choice between two pills.\n\n```rust\nenum Pill {\n    Red,\n    Blue,\n}\n\nfn main() {\n  let choice = Pill::Red; // Neo chooses the Red pill\n  match choice {\n    Pill::Red => println!(\\\"Welcome to the real world.\\\"),\n    Pill::Blue => println!(\\\"Stay in the dream.\\\"),\n  }\n}\n```\n\nHere, the `Pill` enum has two variants: `Red` and `Blue`. Neo's choice is represented by one of these variants. The `match` statement then acts like Morpheus, interpreting Neo's decision.",
        "task": "Given the following code snippet, complete the missing parts of the code where indicated by '/* TODO: */'. You need to add another variant to the `Pill` enum and handle it in the `match` statement.\n\n```rust\nenum Pill {\n    Red,\n    Blue,\n    /* TODO: Add another variant here */\n}\n\nfn main() {\n  let choice = /* TODO: Assign your new variant as the choice */\n  match choice {\n    Pill::Red => println!(\\\"Welcome to the real world.\\\"),\n    Pill::Blue => println!(\\\"Stay in the dream.\\\"),\n    /* TODO: Add a match arm for your new variant */\n  }\n}\n```\n\n**Plan:**\n1. Declare a new variant for the `Pill` enum.\n2. Assign the new variant to `choice` in the `main` function.\n3. Add a new match arm in the `match` statement to handle your new variant. Start with the first step."
      },
      {
        "order": 2,
        "heading": "Enums with Data",
        "content": "Enums in Rust can be used to store different types of data for each variant. This makes enums versatile for various applications. Consider the following example:\n\n```rust\nenum Character {\n  Warrior { power: u32 },\n  Archer { accuracy: u32 },\n}\n\nfn main() {\n  let character = Character::Warrior { power: 100 };\n\n  match character {\n    Character::Warrior { power } => println!(\"Warrior with power: {}\", power),\n    Character::Archer { accuracy } => println!(\"Archer with accuracy: {}\", accuracy),\n  }\n}\n```\nHere, the `Character` enum has two variants, each holding different data: `power` for a `Warrior` and `accuracy` for an `Archer`. The `match` statement is used to extract and print this data based on the character's type.",
        "task": "Here is a code snippet with parts for you to complete:\n\n```rust\nenum Character {\n  Warrior { power: u32 },\n  Archer { accuracy: u32 },\n}\n\nfn main() {\n  let character = Character::>>>Insert correct variant here<<< { >>>Insert corresponding attribute<<<: 100 };\n\n  match character {\n    Character::Warrior { power } => println!(\"Warrior with power: {}\", power),\n    Character::Archer { accuracy } => println!(\"Archer with accuracy: {}\", accuracy),\n  }\n}\n```\nThis snippet is an example of using enums with data in Rust. Your tasks are:\n1. Choose the correct variant of the `Character` enum and insert it where indicated.\n2. Add the appropriate attribute (`power` for `Warrior`, `accuracy` for `Archer`) and its value for the selected variant."
      },
      {
        "order": 3,
        "heading": "Methods in Enums",
        "content": "Enums in Rust can have methods associated with them, allowing for behavior specific to each variant. This feature can be utilized to execute variant-specific logic. For instance:\n\n```rust\nenum Direction {\n  North,\n  South,\n}\n\nimpl Direction {\n  fn describe(&self) {\n    match self {\n      Direction::North => println!(\"Heading North.\"),\n      Direction::South => println!(\"Heading South.\"),\n    }\n  }\n}\n\nfn main() {\n  let my_direction = Direction::North;\n  my_direction.describe();\n}\n```\nIn this code, the `Direction` enum includes two variants: `North` and `South`. The `describe` method is implemented to print a message according to the variant. This demonstrates how methods can be defined on enums to perform actions specific to their variants.",
        "task": "Your task is to fill in the missing parts of this Rust code snippet:\n\n```rust\nenum Direction {\n  North,\n  South,\n}\n\nimpl Direction {\n  fn describe(&self) {\n    match self {\n      Direction::>>>Insert correct variant here<<< => println!(\"Heading >>>Insert correct direction<<<.\"),\n      Direction::>>>Insert correct variant here<<< => println!(\"Heading >>>Insert correct direction<<<.\"),\n    }\n  }\n}\n\nfn main() {\n  let my_direction = Direction::North; // Example direction\n  my_direction.describe();\n}\n```\nThis exercise involves creating a method on an enum that prints a message based on the enum's variant. You need to:\n1. Insert the correct variant names in the `match` arms.\n2. Complete the messages to reflect the direction associated with each variant."
      },
      {
        "order": 4,
        "heading": "Option handling with Enums",
        "content": "The `Option` enum in Rust is a powerful tool for handling the presence or absence of a value. It can take the values `Some(value)` or `None`, helping to avoid null-related errors common in other languages. Here is a straightforward example:\n\n```rust\nfn main() {\n  let some_value: Option<&str> = Some(\"A value\");\n\n  match some_value {\n    Some(inner_value) => println!(\"The value is {}\", inner_value),\n    None => println!(\"There is no value.\"),\n  }\n}\n```\nIn this example, `some_value` is an `Option` that is currently `Some(\"A value\")`. The `match` expression then either prints this value (if it exists) or states that there is no value (if it doesnâ€™t).",
        "task": "Complete the missing parts in the following Rust code based on Option enums:\n\n```rust\nfn main() {\n  let some_value: Option<&str> = >>>Insert either Some with a string or None<<<;\n\n  match some_value {\n    Some(inner_value) => println!(\"The value is {}\", inner_value),\n    None => println!(\"There is no value.\"),\n  }\n}\n```\nIn this task, you need to:\n1. Decide whether `some_value` should contain a `Some` with a string value or `None`.\n2. Insert the appropriate Rust syntax to represent your decision in the assignment of `some_value`."
      },
      {
        "order": 5,
        "heading": "Error handling with Enums",
        "content": "Error handling is essential for robust Rust programs, and enums are central to Rust's approach. Specifically, the `Result` type is a variant of an enum that represents either success (`Ok`) or failure (`Err`). Here's how it can be applied:\n\n```rust\nenum ServerError {\n  Timeout,\n  Unauthorized,\n  ResourceNotFound,\n}\n\nfn request_data() -> Result<String, ServerError> {\n  if rand::random() {\n      Ok(\"Data successfully retrieved\".to_string())\n    } else {\n      Err(ServerError::Unauthorized)\n    }\n}\n\nfn main() {\n  match request_data() {\n      Ok(data) => println!(\"Success: {}\", data),\n      Err(ServerError::Timeout) => println!(\"Error: Request timed out.\"),\n      Err(ServerError::Unauthorized) => println!(\"Error: Unauthorized access.\"),\n      Err(ServerError::ResourceNotFound) => println!(\"Error: Resource not found.\"),\n  }\n}\n```\nIn this code, `ServerError` lists potential errors. `request_data` simulates a request, returning either data or an error. The `main` function uses a `match` to handle these outcomes.",
        "task": "Your task is to fill in the missing parts of this Rust code snippet regarding error handling:\n\n```rust\nenum ServerError {\n  Timeout,\n  Unauthorized,\n  ResourceNotFound,\n}\n\nfn request_data() -> Result<String, ServerError> {\n  // Simulate a data request\n  if rand::random() {\n      Ok(>>>Insert successful data message<<<)\n    } else {\n      Err(ServerError::>>>Choose an error<<<)\n    }\n}\n\nfn main() {\n  match request_data() {\n      Ok(data) => println!(\"Success: {}\", data),\n      Err(ServerError::Timeout) => println!(\"Error: Request timed out.\"),\n      Err(ServerError::Unauthorized) => println!(\"Error: Unauthorized access.\"),\n      Err(ServerError::ResourceNotFound) => println!(\"Error: Resource not found.\"),\n  }\n}\n```\n1. Provide a message for successful data retrieval in the `Ok` branch of the `request_data` function.\n2. Select an appropriate error variant for the `Err` branch in the `request_data` function."
      },
      {
        "order": 6,
        "heading": "Enums with Match Guards",
        "content": "Match guards in Rust are conditions that can be added to `match` arms to provide additional control over which arm is selected. This feature is particularly useful for implementing complex decision-making logic. Here's a simple example:\n\n```rust\nenum Activity {\n  Combat,\n  Recon,\n}\n\nfn choose_activity(energy_level: u32) -> Activity {\n  match energy_level {\n    energy if energy > 50 => Activity::Combat,\n    _ => Activity::Recon,\n  }\n}\n\nfn main() {\n  let current_energy = 40;\n  let activity = choose_activity(current_energy);\n\n  match activity {\n    Activity::Combat => println!(\"Prepare for combat!\"),\n    Activity::Recon => println!(\"Time for reconnaissance.\"),\n  }\n}\n```\nIn this example, the `choose_activity` function decides whether to engage in `Combat` or `Recon` based on the `energy_level`. A match guard (`energy if energy > 50`) is used to determine the appropriate `Activity`.",
        "task": "Now, complete the missing parts in this Rust code snippet using match guards:\n\n```rust\nenum Activity {\n  Combat,\n  Recon,\n}\n\nfn choose_activity(energy_level: u32) -> Activity {\n  match energy_level {\n    >>>Insert the condition with a match guard for Combat<<< => Activity::Combat,\n    _ => Activity::Recon,\n  }\n}\n\nfn main() {\n  let current_energy = >>>Insert an integer value<<<;\n  let activity = choose_activity(current_energy);\n\n  match activity {\n    Activity::Combat => println!(\"Prepare for combat!\"),\n    Activity::Recon => println!(\"Time for reconnaissance.\"),\n  }\n}\n```\nYour tasks are:\n1. Apply a match guard for the `Combat` scenario based on the `energy_level`.\n2. Provide a specific energy level for the `current_energy` variable in `main`."
      },
      {
        "order": 7,
        "heading": "Enums with Generics",
        "content": "Generics are a powerful feature in Rust that allow for type abstraction and code reusability. Combined with enums, generics enable the creation of flexible and adaptable data structures. Here's an example:\n\n```rust\nenum Entity<T, U> {\n  Person(T),\n  Object(U),\n}\n\nfn main() {\n  let john: Entity<&str, i32> = Entity::Person(\"Explorer\");\n  let artifact: Entity<i32, &str> = Entity::Object(\"Ancient Relic\");\n\n  match john {\n    Entity::Person(name) => println!(\"John is known as {}\", name),\n    Entity::Object(_) => println!(\"This is an object, not a person\"),\n  }\n\n  match artifact {\n    Entity::Person(_) => println!(\"This is a person, not an object\"),\n    Entity::Object(description) => println!(\"Object identified: {}\", description),\n  }\n}\n```\nIn this code, `Entity` is a generic enum with variants `Person` and `Object`, which can take different types of data. This allows the same enum to be used in different contexts, demonstrating the versatility of generics.",
        "task": "Complete the missing parts in this Rust code using enums with generics:\n\n```rust\nenum Entity<T, U> {\n  Person(T),\n  Object(U),\n}\n\nfn main() {\n  let character: Entity<>>>Insert a type<<<, >>>Insert another type<<<> = Entity::Person(>>>Insert a value<<<);\n  let item: Entity<>>>Insert a type<<<, >>>Insert another type<<<> = Entity::Object(>>>Insert a value<<<);\n\n  match character {\n    Entity::Person(name) => println!(\"Character identified: {}\", name),\n    Entity::Object(_) => println!(\"This is not a character\"),\n  }\n\n  match item {\n    Entity::Person(_) => println!(\"This is not an item\"),\n    Entity::Object(description) => println!(\"Item description: {}\", description),\n  }\n}\n```\nYour tasks are:\n1. Fill in the appropriate types for `Entity` instances in `main`.\n2. Provide values for these instances that match their types."
      },
      {
        "order": 8,
        "heading": "Enum Forwarding with Delegation",
        "content": "In Rust, enums can be combined with traits to delegate responsibilities, allowing for polymorphic behavior among enum variants. This pattern is similar to trait implementation for structs but applied to enum variants. Here's an illustrative example:\n\n```rust\ntrait Response {\n  fn respond(&self);\n}\n\nenum Role {\n  Leader,\n  Scout,\n  Technician,\n}\n\nimpl Response for Role {\n  fn respond(&self) {\n    match self {\n      Role::Leader => println!(\"The leader gives an order.\"),\n      Role::Scout => println!(\"The scout scouts ahead.\"),\n      Role::Technician => println!(\"The technician fixes the issue.\"),\n    }\n  }\n}\n\nfn main() {\n  let role = Role::Technician;\n  role.respond();\n}\n```\nIn this example, `Role` is an enum with different types of roles. By implementing the `Response` trait for `Role`, each variant can provide a unique response when the `respond` method is called.",
        "task": "Fill in the missing parts of this Rust code snippet related to enum forwarding with delegation:\n\n```rust\ntrait Action {\n  fn perform(&self);\n}\n\nenum Position {\n  Captain,\n  Navigator,\n  Engineer,\n}\n\nimpl Action for Position {\n  fn perform(&self) {\n    match self {\n      Position::>>>Insert the correct variant<<< => println!(\"The captain steers the ship.\"),\n      Position::Navigator => println!(\"The navigator plots the course.\"),\n      Position::Engineer => println!(\"The engineer maintains the engine.\"),\n    }\n  }\n}\n\nfn main() {\n  let position = Position::Navigator; // Example position\n  position.perform();\n}\n```\nYour tasks are:\n1. Correctly fill in the missing variant in the `match` statement within the `perform` method.\n2. Ensure that each variant of `Position` has a unique action associated with it when the `perform` method is called."
      },
      {
        "order": 9,
        "heading": "Enums in State Design Pattern",
        "content": "The State design pattern can be efficiently implemented using enums in Rust, allowing an object to change its behavior when its internal state changes. This approach encapsulates state-specific behaviors within enum variants, leading to organized and modular code. Consider this example:\n\n```rust\nenum EnvironmentState {\n    Earth,\n    Space,\n}\n\nimpl EnvironmentState {\n    fn transition(&self) -> EnvironmentState {\n        match self {\n            EnvironmentState::Earth => EnvironmentState::Space,\n            EnvironmentState::Space => EnvironmentState::Earth,\n        }\n    }\n}\n\nfn main() {\n    let current_env = EnvironmentState::Earth;\n    let next_env = current_env.transition();\n    // next_env is now Space\n}\n```\nIn this example, `EnvironmentState` switches between `Earth` and `Space`, demonstrating how enums can be used to manage state transitions without changing the object's type.",
        "task": "Fill in the missing parts of this Rust code snippet implementing the State design pattern with enums:\n\n```rust\nenum PhaseState {\n    Day,\n    Night,\n}\n\nimpl PhaseState {\n    fn change(&self) -> PhaseState {\n        match self {\n            PhaseState::>>>Insert the correct variant here<<< => PhaseState::Night,\n            PhaseState::Night => PhaseState::Day,\n        }\n    }\n}\n\nfn main() {\n    let current_phase = PhaseState::Day; // Example phase\n    let next_phase = current_phase.change();\n    // next_phase should be Night\n}\n```\nYour tasks are:\n1. Complete the `match` expression by inserting the correct variant for changing from day to night.\n2. Understand how this code implements state transitions using enums."
      },
      {
        "order": 10,
        "heading": "Recursive Enums",
        "content": "Recursive enums in Rust allow for creating complex, self-referencing data structures, ideal for hierarchical or tree-like models. This feature is useful in various domains, such as parsing code in compilers or representing nested file systems. Here's how it can be structured:\n\n```rust\nenum TreeComponent {\n    Branch(String, Vec<TreeComponent>),\n    Leaf(String),\n}\n\nfn main() {\n    let structure = TreeComponent::Branch(\"Root\", vec![\n        TreeComponent::Leaf(\"Leaf A\"),\n        TreeComponent::Branch(\"Branch B\", vec![\n            TreeComponent::Leaf(\"Leaf BA\"),\n            TreeComponent::Leaf(\"Leaf BB\"),\n        ]),\n    ]);\n    // This creates a tree with a root, leaves, and a sub-branch.\n}\n```\nIn this example, `TreeComponent` is a recursive enum with variants `Branch` and `Leaf`. The `Branch` can contain other `TreeComponent` objects, allowing for nested structures similar to directories and files in a file system.",
        "task": "Complete this Rust code snippet to define a tree-like structure using recursive enums:\n\n```rust\nenum BinaryTreeNode {\n    Node(String, Box<>>>Insert the type for left child<<<>, Box<>>>Insert the type for right child<<<>),\n    Leaf(String),\n}\n\nfn main() {\n    let binary_tree = BinaryTreeNode::Node(\"Root\", Box::new(\n        >>>Insert correct variant with content<<<), Box::new(\n        >>>Insert correct variant with content<<<)\n    ));\n    // This should create a binary tree structure with a root and two leaves.\n}\n```\nYour tasks are:\n1. Fill in the correct types and variants for the left and right children of the `Node` variant in the `BinaryTreeNode` enum.\n2. Create a specific instance of this binary tree in the `main` function."
      }
      
      
      
    ]
  }
]
